<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self'; img-src 'self'; font-src 'self';">
    <meta name="description" content="AI Arena v6.0.9 Professional ‚Äî Random Walls + Health Packs + Tactical Combat">
    <meta name="theme-color" content="#0a0a15">
    <meta name="robots" content="noindex">
    <title>üéÆ AI Arena v6.0.9 Professional</title>
    <style>
        :root {
            --bg: #0a0a15; --bg-gradient-start: #0a0a15; --bg-gradient-end: #1a1a2e;
            --panel: #121225; --panel-alpha: rgba(18, 18, 37, 0.95);
            --text: #e0e0ff; --text-dim: #b0b0d0; --text-muted: #707090;
            --primary: #00f2ff; --primary-dark: #00c4d4; --accent: #ff0066;
            --success: #00ff9d; --warning: #ffaa00; --danger: #ff4444;
            --border: #2a2a45; --border-light: #3a3a5a;
            --purple: #aa88ff; --yellow: #ffdd44; --pink: #ff66cc; --cyan: #00d4ff;
            --stat-str: #ff4444; --stat-spd: #4444ff; --stat-hp: #44ff44; --stat-dod: #aa88ff;
            --learning-good: #00ff9d; --learning-bad: #ff5577; --learning-neutral: #ffaa00;
            --mode-combat-bg: rgba(255, 170, 0, 0.15); --mode-combat-text: #ffaa00;
            --sidebar-width: 420px; --header-height: 48px; --panel-radius: 12px;
            --btn-radius: 8px; --input-radius: 6px; --card-radius: 10px;
            --transition-fast: 150ms ease; --transition-normal: 250ms ease;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3); --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.4);
            --z-canvas: 1; --z-sidebar: 10; --z-header: 100; --z-modal: 1000;
        }
        @supports not (--css: variables) {
            body { background: #0a0a15; color: #e0e0ff; }
            .sidebar { background: #121225; }
            .panel { background: rgba(0, 0, 0, 0.3); border-color: #2a2a45; }
        }
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html { font-size: 16px; -webkit-text-size-adjust: 100%; scroll-behavior: smooth; }
        body {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text); font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 0.875rem; line-height: 1.4; overflow: hidden; user-select: none;
            touch-action: manipulation; text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
        }
        :focus-visible { outline: 2px solid var(--primary); outline-offset: 2px; }
        button:focus-visible, input:focus-visible, select:focus-visible {
            outline: 2px solid var(--primary); outline-offset: 2px;
            box-shadow: 0 0 0 4px rgba(0, 242, 255, 0.2);
        }
        .skip-link { position: absolute; top: -40px; left: 0; background: var(--primary); color: #000; padding: 0.5rem 1rem; z-index: var(--z-modal); }
        .skip-link:focus { top: 0; }
        .container {            display: grid; grid-template-columns: 1fr var(--sidebar-width);
            grid-template-rows: var(--header-height) 1fr; grid-template-areas: "header header" "canvas sidebar";
            height: 100vh; width: 100vw;
        }
        .header {
            grid-area: header; background: var(--panel); border-bottom: 1px solid var(--border);
            padding: 0.5rem 1rem; display: flex; justify-content: space-between; align-items: center;
            z-index: var(--z-header);
        }
        .header h1 { font-size: 1rem; font-weight: 700; color: var(--primary); display: flex; align-items: center; gap: 0.5rem; margin: 0; }
        .version-badge { background: var(--accent); color: #fff; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.625rem; font-weight: 600; }
        .fps-counter { font-family: monospace; color: var(--success); font-weight: 700; font-size: 0.875rem; background: rgba(0, 255, 157, 0.1); padding: 0.25rem 0.5rem; border-radius: 0.375rem; min-width: 70px; text-align: center; }
        #gameCanvas { grid-area: canvas; width: 100%; height: 100%; display: block; cursor: crosshair; touch-action: none; }
        .sidebar {
            grid-area: sidebar; background: var(--panel); border-left: 1px solid var(--border);
            padding: 0.625rem; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem;
            scrollbar-width: thin; scrollbar-color: var(--border) var(--bg);
        }
        .sidebar::-webkit-scrollbar { width: 0.25rem; }
        .sidebar::-webkit-scrollbar-track { background: var(--bg); }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 0.125rem; }
        .panel {
            background: var(--panel-alpha); border: 1px solid var(--border); border-radius: var(--panel-radius);
            padding: 0.5rem; backdrop-filter: blur(4px);
        }
        .panel-title { color: var(--primary); font-size: 0.75rem; font-weight: 700; margin-bottom: 0.375rem; display: flex; align-items: center; gap: 0.3125rem; padding-bottom: 0.25rem; border-bottom: 1px solid var(--border); text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; }
        .stat { background: rgba(0, 0, 0, 0.2); padding: 0.25rem 0.375rem; border-radius: 0.375rem; font-size: 0.625rem; border: 1px solid transparent; }
        .stat:hover { border-color: var(--border-light); background: rgba(0, 0, 0, 0.25); }
        .stat-label { color: var(--text-dim); display: block; margin-bottom: 0.0625rem; font-size: 0.5625rem; }
        .stat-value { color: var(--primary); font-weight: 700; font-family: monospace; font-size: 0.6875rem; }
        .stat-value.good { color: var(--success); } .stat-value.bad { color: var(--danger); }
        .control-group { margin-bottom: 0.375rem; }
        .control-label { display: flex; justify-content: space-between; align-items: center; font-size: 0.6875rem; margin-bottom: 0.125rem; color: var(--text-dim); }
        input[type="range"] { width: 100%; height: 0.25rem; background: var(--border); border-radius: 0.125rem; appearance: none; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 0.75rem; height: 0.75rem; background: var(--primary); border-radius: 50%; cursor: pointer; border: 2px solid var(--bg); }
        select { width: 100%; padding: 0.375rem 0.5rem; background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border); border-radius: var(--input-radius); color: var(--text); font-size: 0.6875rem; cursor: pointer; }
        .btn-group { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        .btn-group-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        button {
            padding: 0.375rem 0.5rem; border: none; border-radius: var(--btn-radius); font-weight: 700;
            cursor: pointer; font-size: 0.6875rem; background: var(--border); color: var(--text);
            min-height: 2rem; transition: all var(--transition-fast); text-transform: uppercase; letter-spacing: 0.5px;
            display: flex; align-items: center; justify-content: center; gap: 0.25rem; position: relative; overflow: hidden;
        }
        button:hover:not(:disabled) { background: var(--border-light); }
        button:active { transform: translateY(1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: var(--primary); color: #000; }
        .btn-danger { background: var(--danger); color: #fff; }        .btn-success { background: var(--success); color: #000; }
        .btn-secondary { background: var(--border); color: var(--text); }
        .btn-toggle.active { background: var(--accent); color: #fff; }
        .toggle { display: flex; align-items: center; gap: 0.25rem; font-size: 0.6875rem; margin-bottom: 0.1875rem; color: var(--text-dim); cursor: pointer; user-select: none; }
        .toggle input { accent-color: var(--primary); width: 0.875rem; height: 0.875rem; cursor: pointer; }
        .log {
            background: #000; border: 1px solid var(--border); border-radius: 0.5rem; padding: 0.375rem;
            height: 5.625rem; overflow-y: auto; font-size: 0.5625rem; font-family: monospace;
            word-break: break-word; white-space: pre-wrap;
        }
        .log-entry { margin-bottom: 0.125rem; padding-bottom: 0.125rem; border-bottom: 1px solid #111; line-height: 1.3; }
        .log-entry.info { color: var(--primary); } .log-entry.success { color: var(--success); }
        .log-entry.warn { color: var(--warning); } .log-entry.error { color: var(--danger); }
        .progress-bar { height: 0.25rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.1875rem; overflow: hidden; margin-top: 0.1875rem; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--primary), var(--success)); transition: width var(--transition-normal); }
        .agent-card {
            display: flex; flex-direction: column; gap: 0.25rem; padding: 0.375rem;
            background: rgba(0, 0, 0, 0.2); border-radius: var(--card-radius); margin-bottom: 0.375rem;
            border-left: 3px solid transparent;
        }
        .agent-card.blue { border-left-color: var(--primary); }
        .agent-card.red { border-left-color: var(--accent); }
        .agent-header { display: flex; align-items: center; gap: 0.25rem; font-size: 0.6875rem; font-weight: 600; }
        .health-bar { height: 0.1875rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.125rem; overflow: hidden; }
        .health-fill { height: 100%; background: linear-gradient(90deg, var(--success), var(--primary)); transition: width var(--transition-fast); }
        .agent-stats { display: flex; justify-content: space-between; font-size: 0.5625rem; color: var(--text-dim); flex-wrap: wrap; gap: 0.125rem; }
        .agent-stats b { color: var(--text); font-weight: 600; }
        .stat-badge {
            display: inline-flex; align-items: center; padding: 0.0625rem 0.1875rem;
            border-radius: 0.125rem; font-size: 0.5rem; font-weight: 600; margin-right: 0.125rem; border: 1px solid transparent;
        }
        .stat-badge.stat-hp { background: rgba(68, 255, 68, 0.15); color: var(--stat-hp); }
        .stat-badge.stat-str { background: rgba(255, 68, 68, 0.15); color: var(--stat-str); }
        .stat-badge.stat-spd { background: rgba(68, 68, 255, 0.15); color: var(--stat-spd); }
        .stat-badge.stat-dod { background: rgba(170, 136, 255, 0.15); color: var(--stat-dod); }
        .weapon-badge {
            display: inline-flex; align-items: center; gap: 0.125rem; padding: 0.0625rem 0.25rem;
            border-radius: 0.25rem; font-size: 0.5rem; font-weight: 600; margin-top: 0.125rem;
            background: rgba(255, 170, 0, 0.15); color: var(--warning); border: 1px solid var(--warning);
        }
        .skills-display { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.125rem; margin-top: 0.1875rem; }
        .skill-item { text-align: center; font-size: 0.5rem; }
        .skill-bar { height: 0.125rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.0625rem; margin-top: 0.0625rem; overflow: hidden; }
        .skill-fill { height: 100%; transition: width var(--transition-normal); }
        .skill-combat .skill-fill { background: var(--warning); }
        .skill-flee .skill-fill { background: var(--danger); }
        .skill-explore .skill-fill { background: var(--primary); }
        .skill-avoid .skill-fill { background: var(--purple); }
        .mode-badge {
            display: inline-flex; align-items: center; padding: 0.0625rem 0.25rem;            border-radius: 0.375rem; font-size: 0.5rem; font-weight: 600; margin-left: 0.25rem;
        }
        .mode-combat { background: var(--mode-combat-bg); color: var(--mode-combat-text); }
        .learning-metrics { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.1875rem; margin-top: 0.25rem; }
        .metric-item { background: rgba(0, 0, 0, 0.2); padding: 0.1875rem 0.25rem; border-radius: 0.25rem; font-size: 0.5rem; }
        .metric-label { color: var(--text-dim); display: block; font-size: 0.4375rem; }
        .metric-value { color: var(--learning-good); font-weight: 600; font-family: monospace; }
        .learning-progress { display: flex; flex-direction: column; gap: 0.125rem; margin-top: 0.25rem; }
        .progress-row { display: flex; align-items: center; gap: 0.25rem; font-size: 0.5rem; }
        .progress-label { width: 4.375rem; color: var(--text-dim); flex-shrink: 0; }
        .progress-track { flex: 1; height: 0.1875rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.125rem; overflow: hidden; }
        .progress-track.td .progress-fill { background: linear-gradient(90deg, var(--danger), var(--warning), var(--success)); }
        .progress-track.entropy .progress-fill { background: linear-gradient(90deg, var(--warning), var(--primary)); }
        .debug-panel {
            background: rgba(0, 0, 0, 0.4); border: 1px solid var(--border); border-radius: 0.5rem;
            padding: 0.375rem; font-size: 0.5625rem; display: none;
        }
        .debug-panel.active { display: block; }
        .debug-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.125rem 0.25rem; }
        .debug-item { display: flex; justify-content: space-between; padding: 0.0625rem 0; }
        .debug-label { color: var(--text-dim); }
        .debug-value { color: var(--primary); font-weight: 600; font-family: monospace; }
        .separator { height: 1px; background: var(--border); margin: 0.375rem 0; }
        input[type="file"] { display: none; }
        @media (max-width: 1100px) {
            .container { grid-template-columns: 1fr !important; grid-template-rows: var(--header-height) 1fr auto !important; grid-template-areas: "header" "canvas" "sidebar" !important; }
            .sidebar { border-left: none !important; border-top: 1px solid var(--border) !important; max-height: 45vh !important; }
        }
        @media (max-width: 600px) {
            :root { --sidebar-width: 100%; }
            .header { padding: 0.375rem 0.75rem; }
            .header h1 { font-size: 0.875rem; }
            .panel { padding: 0.375rem; }
            .stat-grid { grid-template-columns: repeat(2, 1fr); }
            .btn-group, .btn-group-3 { grid-template-columns: repeat(2, 1fr); }
            .learning-metrics { grid-template-columns: repeat(2, 1fr); }
            .debug-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="#gameCanvas" class="skip-link">–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–∏–º—É–ª—è—Ü–∏–∏</a>
    <div class="container">
        <header class="header">
            <h1>üéÆ AI ARENA <span class="version-badge">v6.0.9 PRO</span></h1>
            <div class="fps-counter" id="fpsCounter">FPS: 0</div>
        </header>
        <canvas id="gameCanvas"></canvas>
        <aside class="sidebar">
            <section class="panel">                <h2 class="panel-title">‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò</h2>
                <div class="control-group">
                    <label class="control-label"><span>–ê–≥–µ–Ω—Ç–æ–≤ –Ω–∞ –∫–æ–º–∞–Ω–¥—É</span><span id="agentCountValue">2</span></label>
                    <input type="range" id="agentCount" min="1" max="8" step="1" value="2">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>üëÅÔ∏è –ó—Ä–µ–Ω–∏–µ (—Ä–∞–¥–∏—É—Å)</span><span id="viewRadiusValue">250</span></label>
                    <input type="range" id="viewRadius" min="100" max="600" step="25" value="250">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>üîµ BLUE</span></label>
                    <select id="blueWeaponSelect">
                        <option value="hammer">üî® Hammer</option>
                        <option value="drill">üî© Drill</option>
                        <option value="sword">‚öîÔ∏è Sword</option>
                        <option value="blaster">üî´ Blaster</option>
                        <option value="axe">ü™ì Axe</option>
                        <option value="dagger">üó°Ô∏è Dagger</option>
                        <option value="spear">üî± Spear</option>
                        <option value="chainsaw">‚öôÔ∏è Chainsaw</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label"><span>üî¥ RED</span></label>
                    <select id="redWeaponSelect">
                        <option value="hammer">üî® Hammer</option>
                        <option value="drill">üî© Drill</option>
                        <option value="sword">‚öîÔ∏è Sword</option>
                        <option value="blaster">üî´ Blaster</option>
                        <option value="axe">ü™ì Axe</option>
                        <option value="dagger">üó°Ô∏è Dagger</option>
                        <option value="spear">üî± Spear</option>
                        <option value="chainsaw">‚öôÔ∏è Chainsaw</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button class="btn-success" id="btnApplyWeapons">‚úÖ –ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
                    <button class="btn-secondary" id="btnRandomWeapons">üé≤ –°–ª—É—á–∞–π–Ω–æ</button>
                </div>
                <div class="separator"></div>
                <div class="control-group">
                    <label class="control-label"><span>üß± –ö–æ–ª-–≤–æ —Å—Ç–µ–Ω</span><span id="wallCountValue">3</span></label>
                    <input type="range" id="wallCount" min="2" max="5" step="1" value="3">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>–î–ª–∏–Ω–∞ —Å—Ç–µ–Ω</span><span id="wallLengthValue">120</span></label>
                    <input type="range" id="wallLength" min="60" max="200" step="10" value="120">
                </div>
                <div class="btn-group">
                    <button class="btn-secondary" id="btnRegenerateWalls">üîÑ –ü–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å</button>                    <button class="btn-toggle" id="btnShowGrid">‚äû –°–µ—Ç–∫–∞</button>
                </div>
            </section>
            <section class="panel">
                <h2 class="panel-title">üë• –í–°–ï –ê–ì–ï–ù–¢–´</h2>
                <div id="agentList"></div>
            </section>
            <section class="panel">
                <h2 class="panel-title">üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê</h2>
                <div class="stat-grid">
                    <div class="stat"><span class="stat-label">–≠–ø–∏–∑–æ–¥</span><span class="stat-value" id="episodeStat">0</span></div>
                    <div class="stat"><span class="stat-label">–®–∞–≥</span><span class="stat-value" id="stepStat">0</span></div>
                    <div class="stat"><span class="stat-label">–ë–æ–∏</span><span class="stat-value" id="totalFightsStat">0</span></div>
                    <div class="stat"><span class="stat-label">–°—Ç–µ–Ω—ã</span><span class="stat-value" id="obstaclesStat">3</span></div>
                </div>
                <div class="progress-bar"><div class="progress-fill" id="episodeProgress" style="width: 0%"></div></div>
            </section>
            <section class="panel">
                <h2 class="panel-title">üß† –û–ë–£–ß–ï–ù–ò–ï</h2>
                <div class="control-group">
                    <label class="control-label"><span>Learning Rate</span><span id="learningRateValue">0.015</span></label>
                    <input type="range" id="learningRate" min="0.001" max="0.05" step="0.001" value="0.015">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>TD Lambda</span><span id="lambdaValue">0.95</span></label>
                    <input type="range" id="lambda" min="0.8" max="0.99" step="0.01" value="0.95">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>Mutation</span><span id="mutationRateValue">0.15</span></label>
                    <input type="range" id="mutationRate" min="0.05" max="0.3" step="0.01" value="0.15">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>–°–∫–æ—Ä–æ—Å—Ç—å</span><span id="agentSpeedValue">10</span></label>
                    <input type="range" id="agentSpeed" min="5" max="20" step="1" value="10">
                </div>
                <div class="separator"></div>
                <label class="toggle"><input type="checkbox" id="enableTraining" checked> TD(Œª) Learning</label>
                <label class="toggle"><input type="checkbox" id="enableEvolution" checked> Evolution</label>
                <label class="toggle"><input type="checkbox" id="enableFighting" checked> –ë–æ–∏</label>
                <label class="toggle"><input type="checkbox" id="enableRanged" checked> –î–∞–ª—å–Ω–∏–π –±–æ–π</label>
                <label class="toggle"><input type="checkbox" id="enableWeightInheritance" checked> –ù–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ</label>
                <label class="toggle"><input type="checkbox" id="enableTactical" checked> –¢–∞–∫—Ç–∏–∫–∞</label>
                <label class="toggle"><input type="checkbox" id="enableHebbian" checked> Hebbian</label>
                <label class="toggle"><input type="checkbox" id="enableConsolidation" checked> Consolidation</label>
                <label class="toggle"><input type="checkbox" id="enableHealthPacks" checked> –ê–ø—Ç–µ—á–∫–∏</label>
                <label class="toggle"><input type="checkbox" id="enableLowHealthHint" checked> –ü–æ–¥—Å–∫–∞–∑–∫–∏ HP</label>
                <label class="toggle"><input type="checkbox" id="enableWalls" checked> –°—Ç–µ–Ω—ã</label>
            </section>
            <section class="panel">
                <h2 class="panel-title">üìà METRICS</h2>                <div class="learning-metrics">
                    <div class="metric-item"><span class="metric-label">TD-Error</span><span class="metric-value" id="metricTDError">0.0000</span></div>
                    <div class="metric-item"><span class="metric-label">Win Rate</span><span class="metric-value" id="metricWinRate">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Damage</span><span class="metric-value" id="metricDamage">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Accuracy</span><span class="metric-value" id="metricAccuracy">0.00</span></div>
                </div>
                <div class="learning-progress">
                    <div class="progress-row"><span class="progress-label">TD Learning</span><div class="progress-track td"><div class="progress-fill" id="progressTD" style="width: 50%"></div></div></div>
                    <div class="progress-row"><span class="progress-label">Combat</span><div class="progress-track pred"><div class="progress-fill" id="progressPred" style="width: 50%"></div></div></div>
                </div>
            </section>
            <section class="panel">
                <h2 class="panel-title">üéÆ –£–ü–†–ê–í–õ–ï–ù–ò–ï</h2>
                <div class="btn-group">
                    <button class="btn-primary" id="btnStart">‚ñ∂ –°—Ç–∞—Ä—Ç</button>
                    <button class="btn-danger" id="btnReset">üîÑ –°–±—Ä–æ—Å</button>
                    <button class="btn-success" id="btnSave">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    <button class="btn-secondary" id="btnLoad">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                </div>
                <div class="btn-group-3">
                    <button class="btn-toggle" id="btnDebug">üîç Debug</button>
                    <button class="btn-toggle" id="btnVision">üëÅÔ∏è Vision</button>
                    <button class="btn-secondary" id="btnExport">üì§ –≠–∫—Å–ø–æ—Ä—Ç</button>
                </div>
                <input type="file" id="fileImport" accept=".json">
            </section>
            <section class="panel">
                <h2 class="panel-title">üìù –õ–û–ì</h2>
                <div id="lowHealthHint" class="panel" style="display:none; background: rgba(255,68,68,0.15); border-color: #ff4444; margin-bottom: 0.375rem;">
                    <div style="font-size: 0.625rem; color: #ffaa00; display: flex; align-items: center; gap: 0.375rem;">
                        <span>üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:</span>
                        <span>–ó–¥–æ—Ä–æ–≤—å–µ < 50%? –ò—â–∏ üß™ –∞–ø—Ç–µ—á–∫–∏ –Ω–∞ –∫–∞—Ä—Ç–µ!</span>
                    </div>
                </div>
                <div class="log" id="eventLog"></div>
            </section>
            <section class="debug-panel" id="debugPanel">
                <h3 style="margin-bottom: 0.25rem; font-weight: 600; color: var(--primary); font-size: 0.625rem;">üîç INSPECTOR</h3>
                <div class="debug-grid" id="debugGrid"></div>
            </section>
        </aside>
    </div>

<script>
'use strict';
// ============================================================================
// PATCH E.1: WALL CLASS - Line segments for proper collision
// ============================================================================
class Wall {
    constructor(x1, y1, x2, y2, type = 'internal') {        this.x1 = x1; this.y1 = y1;
        this.x2 = x2; this.y2 = y2;
        this.type = type;
        this.thickness = 12;
        
        const dx = x2 - x1, dy = y2 - y1;
        this.length = Math.hypot(dx, dy);
        const len = this.length || 1;
        this.normal = { x: -dy / len, y: dx / len };
        this.dir = { x: dx / len, y: dy / len };
    }
    
    distanceToPoint(px, py) {
        const dx = this.x2 - this.x1, dy = this.y2 - this.y1;
        const len2 = dx * dx + dy * dy;
        if (len2 === 0) return Math.hypot(px - this.x1, py - this.y1);
        let t = Math.max(0, Math.min(1, ((px - this.x1) * dx + (py - this.y1) * dy) / len2));
        return Math.hypot(px - (this.x1 + t * dx), py - (this.y1 + t * dy));
    }
    
    blocksLineOfSight(x1, y1, x2, y2) {
        const d1 = (x1 - this.x1) * (this.y2 - this.y1) - (y1 - this.y1) * (this.x2 - this.x1);
        const d2 = (x2 - this.x1) * (this.y2 - this.y1) - (y2 - this.y1) * (this.x2 - this.x1);
        const d3 = (this.x1 - x1) * (y2 - y1) - (this.y1 - y1) * (x2 - x1);
        const d4 = (this.x2 - x1) * (y2 - y1) - (this.y2 - y1) * (x2 - x1);
        return ((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0));
    }
    
    draw(ctx) {
        ctx.strokeStyle = this.type === 'border' ? '#8a8aba' : '#6a6a9a';
        ctx.lineWidth = this.thickness;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(this.x1, this.y1);
        ctx.lineTo(this.x2, this.y2);
        ctx.stroke();
        
        ctx.strokeStyle = this.type === 'border' ? '#9a9aca' : '#7a7aaa';
        ctx.lineWidth = this.thickness - 4;
        ctx.beginPath();
        ctx.moveTo(this.x1, this.y1);
        ctx.lineTo(this.x2, this.y2);
        ctx.stroke();
    }
    
    toJSON() {
        return { x1: this.x1, y1: this.y1, x2: this.x2, y2: this.y2, type: this.type, thickness: this.thickness };
    }
    
    static fromJSON(data) {        return new Wall(data.x1, data.y1, data.x2, data.y2, data.type);
    }
}

// ============================================================================
// PATCH E.2: RANDOM WALL GENERATOR ‚Äî FIXED VERSION
// ============================================================================
const WallGenerator = Object.freeze({
    generateRandomWalls: function(width, height, count = 3, baseLength = 120, seed = null) {
        const rng = seed ? new SeededRNG(seed + '_WALLS') : { next: () => Math.random() };
        const walls = [];
        const margin = 80;
        const minLength = baseLength * 0.7;
        const maxLength = baseLength * 1.3;
        const minDistance = 100;
        
        let attempts = 0;
        const maxAttempts = count * 50;
        
        while (walls.length < count && attempts < maxAttempts) {
            attempts++;
            
            const cx = margin + rng.next() * (width - margin * 2);
            const cy = margin + rng.next() * (height - margin * 2);
            const length = minLength + rng.next() * (maxLength - minLength);
            const angle = rng.next() * Math.PI;
            
            const x1 = cx - Math.cos(angle) * length / 2;
            const y1 = cy - Math.sin(angle) * length / 2;
            const x2 = cx + Math.cos(angle) * length / 2;
            const y2 = cy + Math.sin(angle) * length / 2;
            
            // ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê: —Å—Ç–µ–Ω–∞ –î–û–õ–ñ–ù–ê –±—ã—Ç—å –≤–Ω—É—Ç—Ä–∏ –≥—Ä–∞–Ω–∏—Ü
            if (x1 < margin || x1 > width - margin || y1 < margin || y1 > height - margin ||
                x2 < margin || x2 > width - margin || y2 < margin || y2 > height - margin) {
                continue;
            }
            
            // ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –¥–æ –¥—Ä—É–≥–∏—Ö —Å—Ç–µ–Ω
            let tooClose = false;
            for (const existing of walls) {
                const ex = (existing.x1 + existing.x2) / 2;
                const ey = (existing.y1 + existing.y2) / 2;
                if (Math.hypot(cx - ex, cy - ey) < minDistance) {
                    tooClose = true;
                    break;
                }
            }
            if (tooClose) continue;
                        // ‚úÖ –í—Å—ë –ø—Ä–æ—à–ª–æ ‚Äî –¥–æ–±–∞–≤–ª—è–µ–º —Å—Ç–µ–Ω—É
            walls.push(new Wall(x1, y1, x2, y2, 'internal'));
        }
        
        // üõ°Ô∏è FALLBACK: –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å ‚Äî —Å–æ–∑–¥–∞—ë–º –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
        if (walls.length === 0 && count > 0) {
            const fallbackPositions = [
                { x1: 200, y1: 150, x2: 200, y2: 450 },
                { x1: 600, y1: 150, x2: 600, y2: 450 },
                { x1: 300, y1: 300, x2: 500, y2: 300 },
                { x1: 250, y1: 200, x2: 400, y2: 400 },
                { x1: 450, y1: 200, x2: 600, y2: 400 }
            ];
            for (let i = 0; i < Math.min(count, fallbackPositions.length); i++) {
                const p = fallbackPositions[i];
                walls.push(new Wall(p.x1, p.y1, p.x2, p.y2, 'internal'));
            }
        }
        
        // üß± –ì—Ä–∞–Ω–∏—á–Ω—ã–µ —Å—Ç–µ–Ω—ã ‚Äî –≤—Å–µ–≥–¥–∞
        walls.push(new Wall(0, 0, width, 0, 'border'));
        walls.push(new Wall(width, 0, width, height, 'border'));
        walls.push(new Wall(width, height, 0, height, 'border'));
        walls.push(new Wall(0, height, 0, 0, 'border'));
        
        return { walls, generated: walls.filter(w => w.type === 'internal').length };
    }
});

// ============================================================================
// SECTION 1: CONFIGURATION & CONSTANTS
// ============================================================================

const WEAPONS = Object.freeze({
    hammer: { name: 'Hammer', icon: 'üî®', damage: 1.0, speed: 1.0, range: 45, type: 'melee', knockback: 8.0, knockbackType: 'impact', color: '#ffaa00', stunTime: 5, arcAngle: Math.PI * 0.9, mountOffset: { x: 24, y: 0 }, recoil: { x: -2, y: 0 }, recoilStrength: 0.15 },
    drill: { name: 'Drill', icon: 'üî©', damage: 0.6, speed: 1.8, range: 40, type: 'melee', knockback: 2.0, knockbackType: 'vibrate', color: '#ff66cc', stunTime: 2, arcAngle: Math.PI * 0.6, mountOffset: { x: 22, y: 0 }, recoil: { x: -1, y: 0 }, recoilStrength: 0.08 },
    sword: { name: 'Sword', icon: '‚öîÔ∏è', damage: 1.4, speed: 0.7, range: 50, type: 'melee', knockback: 12.0, knockbackType: 'slash', color: '#00d4ff', stunTime: 8, arcAngle: Math.PI * 1.2, mountOffset: { x: 26, y: 0 }, recoil: { x: -3, y: 0 }, recoilStrength: 0.18 },
    blaster: { name: 'Blaster', icon: 'üî´', damage: 0.5, speed: 1.2, range: 200, type: 'ranged', knockback: 4.0, knockbackType: 'pulse', color: '#ffdd44', stunTime: 3, arcAngle: Math.PI * 0.4, mountOffset: { x: 20, y: 0 }, recoil: { x: -4, y: 0 }, recoilStrength: 0.22 },
    axe: { name: 'Axe', icon: 'ü™ì', damage: 1.8, speed: 0.5, range: 45, type: 'melee', knockback: 20.0, knockbackType: 'heavy', color: '#ff4444', stunTime: 15, arcAngle: Math.PI * 0.7, mountOffset: { x: 25, y: 0 }, recoil: { x: -5, y: 0 }, recoilStrength: 0.28 },
    dagger: { name: 'Dagger', icon: 'üó°Ô∏è', damage: 0.4, speed: 2.5, range: 35, type: 'melee', knockback: 1.0, knockbackType: 'quick', color: '#aa88ff', stunTime: 1, arcAngle: Math.PI * 1.0, mountOffset: { x: 18, y: 0 }, recoil: { x: -0.5, y: 0 }, recoilStrength: 0.05 },
    spear: { name: 'Spear', icon: 'üî±', damage: 1.1, speed: 0.9, range: 65, type: 'melee', knockback: 10.0, knockbackType: 'thrust', color: '#00ff9d', stunTime: 6, arcAngle: Math.PI * 0.5, mountOffset: { x: 28, y: 0 }, recoil: { x: -2, y: 0 }, recoilStrength: 0.14 },
    chainsaw: { name: 'Chainsaw', icon: '‚öôÔ∏è', damage: 0.8, speed: 1.5, range: 42, type: 'melee', knockback: 3.0, knockbackType: 'continuous', color: '#ff8800', stunTime: 4, arcAngle: Math.PI * 1.1, mountOffset: { x: 23, y: 0 }, recoil: { x: -1, y: 0 }, recoilStrength: 0.10 }
});

window.arenaConfig = {
    enableTraining: true, enableCritic: true, enablePolicySelector: true,
    enableEvolution: true, enableSkillEvolution: true, enableMoE: true,
    enableConsolidation: true, enableFighting: true, enableRanged: true,
    enableHebbian: true, compactInputs: false, enableWeightInheritance: true,
    enableTactical: true, enableReflexPath: true,    enableHealthPacks: true, enableLowHealthHint: true, enableWalls: true,
    learningRate: 0.015, lambda: 0.95, gamma: 0.99, entropyCoeff: 0.01,
    mutationRate: 0.10, skillGrowthRate: 0.04, hebbianRate: 0.002,
    agentSpeed: 10, agentAcceleration: 0.3, agentFriction: 0.90,
    agentCollisionRadius: 22, agentMaxVelocity: 15,
    viewRadius: 250,
    wallCount: 3, wallLength: 120,
    seed: 'ARENA_V6_PRO_' + Date.now().toFixed(0),
    timestamp: Date.now(), version: '6.0.9-PROFESSIONAL',
    ARCH: Object.freeze({
        INPUT_DIM: 64, INPUT_DIM_COMPACT: 25, EMBEDDING_DIM: 24, EMBEDDING_DIM_COMPACT: 16,
        HIDDEN1: 48, HIDDEN2: 36, OUTPUT_DIM: 16, MEMORY_DIM: 16, NUM_HEADS: 4,
        NUM_EXPERTS: 4, EXPERT_DIM: 36, POLICY_CONTEXT_DIM: 8, POLICY_SKILL_DIM: 5,
        POLICY_HIDDEN: 24, POLICY_MODES: 5, CRITIC_HIDDEN: 32, LOGICAL_WIDTH: 850, LOGICAL_HEIGHT: 580
    }),
    PHYSICS: Object.freeze({
        AGENT_COLLISION_RADIUS: 22, AGENT_REPULSION_STRENGTH: 2.5,
        MAX_VELOCITY: 25, VELOCITY_DAMPING: 0.88,
        KNOCKBACK_MASS: 1.0, FRICTION_GROUND: 0.90,
        COLLISION_ELASTICITY: 0.5
    }),
    EVOLUTION: Object.freeze({
        DEATH_PENALTY: 0, FLEE_PENALTY: -0.5, WIN_BONUS: 200,
        LEARN_FROM_WINNER_RATE: 0.50, FORCED_COMBAT_AFTER_DEATH: 30,
        MUTATION_ON_DEATH: 0.10, COMBAT_SKILL_GROWTH: 0.01
    }),
    TACTICAL: Object.freeze({
        FLANK_BONUS: 0.05, FRONT_PENALTY: 0.00, MIN_FLANK_COMMIT: 0.4, CIRCLE_STRENGTH: 0.25,
        RETREAT_HP_THRESHOLD: 0.20, THREAT_BUFFER_ANGLE: Math.PI * 0.1,
        DAMAGE_FRONT: 0.6, DAMAGE_FLANK: 1.0, DAMAGE_BACK: 1.8,
        VICTORY_FOCUS_REWARD: 0.00, EXPOSURE_PENALTY: 0.08,
        COMBAT_STAY_REWARD: 0.15, REVERSE_ONLY_TACTICAL: false,
        FACING_ENEMY_REWARD: 0.00, WALL_PENALTY: 0.05,
        BACKPEDAL_PENALTY: 0.40, AGGRESSIVE_APPROACH_REWARD: 0.45,
        TEAM_FOCUS_BONUS: 0.15, PROTECTION_BONUS: 0.25, REDUNDANCY_PENALTY: 0.20,
        ENCIRCLE_BONUS: 0.30, EXPLORATION_BONUS: 0.10, SPINNING_PENALTY: 0.15
    }),
    CORTEX: Object.freeze({
        DIM_P: 32, DIM_A: 64, DIM_M: 144, DIM_C: 256, DIM_S: 32, DIM_D: 16,
        DIM_SENSOR: 64, NUM_HEADS: 4, HEAD_DIM: 16,
        M_WORK_START: 0, M_WORK_END: 48, M_PERM_START: 48, M_PERM_END: 96, M_PRED_START: 96, M_PRED_END: 144
    }),
    EMOTION: Object.freeze({
        DECAY_RATE: 0.98,
        MOMENTUM_WEIGHT: 0.3,
        COMMITMENT_MIN_FRAMES: 60,
        SATISFACTION_THRESHOLD: 0.6,
        GRUDGE_DECAY: 0.995,
        TRAUMA_DECAY: 0.99,
        INFLUENCE_WEIGHT: 0.35    }),
    DECISION: Object.freeze({
        MIN_FRAMES: {
            attack: 45,
            retreat: 30,
            flank: 60,
            approach: 30
        },
        PHASE_DURATIONS: {
            winding: 10,
            executing: 1,
            completing: 1,
            evaluating: 1
        }
    }),
    OUTPUT: Object.freeze({
        D0_FORWARD: 'forward [0-1]',
        D1_TURN: 'turn [-1 to 1] + prediction',
        D2_ATTACK: 'attack [0-1]',
        D3_DODGE: 'dodge [0-1]',
        D4_AGGRESSION: 'aggression [0-1]',
        D5_FOCUS: 'focus [0-1]',
        D6_DEFENSE: 'defense [0-1]',
        D7_COORDINATION: 'coordination [0-1]',
        D8_CONFIDENCE: 'prediction confidence [0-1]',
        D9_TRAJECTORY: 'trajectory bias [-1 to 1]',
        D10_ENGAGE_RANGE: 'engage_range [0-1]',
        D11_RETREAT_HP: 'retreat_threshold [0-1]',
        D12_STAT_HP: 'upgrade_HP [0-1]',
        D13_STAT_DMG: 'upgrade_DMG [0-1]',
        D14_STAT_DODGE: 'upgrade_DODGE [0-1]',
        D15_STAT_RATE: 'upgrade_FIRE_RATE [0-1]'
    })
};

// ============================================================================
// SECTION 2: UTILITY FUNCTIONS (10/10 OPTIMIZED)
// ============================================================================

const Utils = Object.freeze({
    clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
    lerp: (a, b, t) => a + (b - a) * Utils.clamp(t, 0, 1),
    dist: (a, b) => Math.hypot((a?.x ?? 0) - (b?.x ?? 0), (a?.y ?? 0) - (b?.y ?? 0)),
    normalize: (x, y) => { const l = Math.hypot(x, y); return l > 1e-10 ? { x: x / l, y: y / l } : { x: 0, y: 0 }; },
    tanh: (x) => { if (x > 20) return 1; if (x < -20) return -1; const e = Math.exp(2 * x); return (e - 1) / (e + 1); },
    sigmoid: (x) => { if (x > 20) return 1; if (x < -20) return 0; return 1 / (1 + Math.exp(-x)); },
    leakyRelu: (x, Œ± = 0.01) => x > 0 ? x : Œ± * x,
    argmax: (arr) => { if (!arr || arr.length === 0) return -1; let mi = 0; for (let i = 1; i < arr.length; i++) { if (arr[i] > arr[mi]) mi = i; } return mi; },
    rand: (min, max) => Math.random() * (max - min) + min,
    randInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,    safeNumber: (val, fallback = 0) => (typeof val === 'number' && isFinite(val)) ? val : fallback,
    softmax: (arr, temp = 1) => {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return [];
        const max = Math.max(...arr);
        const exps = arr.map(v => { const scaled = (v - max) / temp; return scaled > 700 ? 0 : Math.exp(Math.min(scaled, 700)); });
        const sum = exps.reduce((s, x) => s + x, 0) || 1e-10;
        return exps.map(e => e / sum);
    },
    logSoftmax: (arr, temp = 1) => {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return [];
        const max = Math.max(...arr);
        const logSumExp = max + Math.log(arr.reduce((s, x) => { const scaled = (x - max) / temp; return s + (scaled > 700 ? 0 : Math.exp(Math.min(scaled, 700))); }, 0) + 1e-10);
        return arr.map(v => ((v - max) / temp - logSumExp));
    },
    policyGradientLoss: (logProbs, advantages) => {
        if (!logProbs?.length || !advantages?.length) return 0;
        const len = Math.min(logProbs.length, advantages.length);
        if (len === 0) return 0;
        let sum = 0;
        for (let i = 0; i < len; i++) { const lp = Utils.safeNumber(logProbs[i], 0); const adv = Utils.safeNumber(advantages[i], 0); sum += lp * adv; }
        return -sum / len;
    },
    entropyBonus: (probs) => {
        if (!probs?.length) return 0;
        let sum = 0;
        for (const p of probs) { const safeP = Math.max(Utils.safeNumber(p, 0), 1e-10); sum += safeP * Math.log(safeP); }
        return -sum;
    },
    moeLoadBalanceLoss: (gateProbs, expertUsage) => {
        if (!gateProbs?.length) return 0;
        const numExperts = gateProbs.length;
        const targetUsage = 1 / numExperts;
        let sum = 0;
        for (let i = 0; i < numExperts; i++) { const usage = Utils.safeNumber(expertUsage?.[i], 0); sum += Math.pow(usage - targetUsage, 2); }
        return sum / numExperts;
    },
    computeGAE: (rewards, values, nextValue, gamma = 0.99, lambda = 0.95) => {
        const advantages = new Array(rewards.length);
        let advantage = 0;
        for (let t = rewards.length - 1; t >= 0; t--) {
            const nextVal = (t === rewards.length - 1) ? nextValue : values[t + 1];
            const delta = Utils.safeNumber(rewards[t], 0) + gamma * Utils.safeNumber(nextVal, 0) - Utils.safeNumber(values[t], 0);
            advantage = delta + gamma * lambda * advantage;
            advantages[t] = advantage;
        }
        return advantages;
    },
    tdError: (reward, value, nextValue, gamma = 0.99) => Utils.safeNumber(reward, 0) + gamma * Utils.safeNumber(nextValue, 0) - Utils.safeNumber(value, 0),
    _pointSegDist: (ax, ay, bx, by, cx, cy) => {
        const vx = bx - ax, vy = by - ay; const wx = cx - ax, wy = cy - ay; const c1 = vx * wx + vy * wy;        if (c1 <= 0) return Math.hypot(cx - ax, cy - ay);
        const c2 = vx * vx + vy * vy;
        if (c2 <= c1) return Math.hypot(cx - bx, cy - by);
        const b = c1 / c2; const pbx = ax + b * vx, pby = ay + b * vy;
        return Math.hypot(cx - pbx, cy - pby);
    },
    hasLineOfSight: (a, b, walls, wallRadius = 6) => {
        if (!a || !b) return false; if (!walls?.length) return true;
        for (const w of walls) {
            if (w instanceof Wall) {
                if (w.blocksLineOfSight(a.x, a.y, b.x, b.y)) return false;
            } else {
                const d = Utils._pointSegDist(a.x, a.y, b.x, b.y, w.x, w.y);
                if (d < wallRadius + 2) return false;
            }
        }
        return true;
    },
    projectInput: (rawInputs, embeddingWeights, bias, outputDim) => {
        const projected = new Array(outputDim).fill(0);
        for (let o = 0; o < outputDim; o++) {
            let sum = Utils.safeNumber(bias?.[o], 0);
            for (let i = 0; i < rawInputs.length; i++) { const w = embeddingWeights?.[i]?.[o]; sum += Utils.safeNumber(rawInputs[i], 0) * Utils.safeNumber(w, 0); }
            projected[o] = Utils.leakyRelu(sum);
        }
        return projected;
    },
    hashSeed: (seed, i, j) => {
        if (!seed) seed = 'default';
        let h = String(seed).split('').reduce((a, c, idx) => { return ((a * 31 + c.charCodeAt(0)) ^ (idx * 17 + i * 7919 + j * 104729)) % 2147483647; }, String(seed).length) || 12345;
        h = (h * 2654435761) >>> 0; return h / 4294967296;
    },
    deepClone: (obj) => {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Float32Array) return new Float32Array(obj);
        if (Array.isArray(obj)) return obj.map(Utils.deepClone);
        const clone = {}; for (const key of Object.keys(obj)) { clone[key] = Utils.deepClone(obj[key]); }
        return clone;
    },
    validateAttention: (scores) => {
        if (!scores?.length || !scores[0]?.length) return { valid: false, error: 'empty' };
        const n = scores.length, m = scores[0].length; let rowSumValid = true;
        for (let i = 0; i < n; i++) { const sum = scores[i].reduce((s, v) => s + v, 0); if (Math.abs(sum - 1) > 0.01) { rowSumValid = false; break; } }
        let hasInvalid = false;
        for (let i = 0; i < n && !hasInvalid; i++) { for (let j = 0; j < m; j++) { if (!isFinite(scores[i][j])) { hasInvalid = true; break; } } }
        return { valid: rowSumValid && !hasInvalid, shape: [n, m], rowSumValid, hasInvalid };
    },
    computeLoadBalance: (usage) => { if (!usage?.length) return 1; const mean = usage.reduce((s, v) => s + v, 0) / usage.length; if (mean < 1e-10) return 1; const variance = usage.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / usage.length; return Math.sqrt(variance) / mean; },
    normalizeAngle: (angle) => { while (angle > Math.PI) angle -= Math.PI * 2; while (angle < -Math.PI) angle += Math.PI * 2; return angle; },
    matrixMultiply: (vec, mat, activation = 'tanh') => {        if (!vec?.length || !mat?.length || !mat[0]?.length) return new Float32Array(0);
        const out = new Float32Array(mat[0].length);
        for (let i = 0; i < mat[0].length; i++) {
            let sum = 0; for (let j = 0; j < vec.length; j++) { sum += Utils.safeNumber(vec[j], 0) * Utils.safeNumber(mat[j]?.[i], 0); }
            switch (activation) { case 'tanh': out[i] = Utils.tanh(sum); break; case 'relu': out[i] = Utils.leakyRelu(sum); break; case 'linear': out[i] = sum; break; default: out[i] = Utils.tanh(sum); }
        }
        return out;
    },
    linearMultiply: (vec, mat) => {
        if (!vec?.length || !mat?.length || !mat[0]?.length) return new Float32Array(0);
        const out = new Float32Array(mat[0].length);
        for (let i = 0; i < mat[0].length; i++) { for (let j = 0; j < vec.length; j++) { out[i] += Utils.safeNumber(vec[j], 0) * Utils.safeNumber(mat[j]?.[i], 0); } }
        return out;
    },
    projectToCortexSensors: (rawInputs, config) => {
        const output = new Float32Array(config.DIM_SENSOR); const src = rawInputs || []; const srcLen = Math.min(src.length, config.DIM_SENSOR);
        for (let i = 0; i < srcLen; i++) { output[i] = Utils.clamp(Utils.safeNumber(src[i], 0), -1, 1); }
        const seed = config?.seed || arenaConfig?.seed || 'CORTEX2_DEFAULT';
        for (let i = srcLen; i < config.DIM_SENSOR; i++) { const hash = Utils.hashSeed(seed, i, 0xDEADBEEF); output[i] = (hash * 2 - 1) * 0.05; }
        return output;
    },
    rotatePoint: (x, y, angle) => ({ x: x * Math.cos(angle) - y * Math.sin(angle), y: x * Math.sin(angle) + y * Math.cos(angle) }),
    pointInRotatedRect: (px, py, cx, cy, angle, halfW, halfH) => {
        const dx = px - cx, dy = py - cy;
        const localX = dx * Math.cos(-angle) - dy * Math.sin(-angle);
        const localY = dx * Math.sin(-angle) + dy * Math.cos(-angle);
        return Math.abs(localX) <= halfW && Math.abs(localY) <= halfH;
    },
    angleToTarget: (fromX, fromY, toX, toY, currentFacing) => {
        const targetAngle = Math.atan2(toY - fromY, toX - fromX);
        return Utils.normalizeAngle(targetAngle - currentFacing);
    },
    calculateExposure: (agent, enemy) => {
        if (!enemy || !enemy.alive) return { level: 0, type: 'none' };
        const toEnemy = Math.atan2(enemy.y - agent.y, enemy.x - agent.x);
        const angleDiff = Math.abs(Utils.normalizeAngle(toEnemy - agent.facingAngle));
        if (angleDiff < Math.PI * 0.17) return { level: 0.0, type: 'front' };
        if (angleDiff < Math.PI * 0.5) return { level: 0.5, type: 'flank' };
        return { level: 1.0, type: 'back' };
    },
    angleDistribution: (angles) => {
        if (angles.length < 2) return Math.PI * 2;
        const sorted = [...angles].sort((a, b) => a - b);
        let maxGap = 0;
        for (let i = 0; i < sorted.length; i++) {
            const gap = sorted[(i + 1) % sorted.length] - sorted[i];
            maxGap = Math.max(maxGap, gap < 0 ? gap + Math.PI * 2 : gap);
        }
        return maxGap;
    },    threatScore: (agent, target) => {
        const weaponThreat = { axe: 1.0, sword: 0.85, spear: 0.7, hammer: 0.6, chainsaw: 0.55, blaster: 0.5, drill: 0.4, dagger: 0.3 };
        const wThreat = weaponThreat[target.weaponType] || 0.5;
        const hpFactor = target.health / target.stats.maxHealth;
        const speedFactor = Math.min(1, Math.hypot(target.vx || 0, target.vy || 0) / 10);
        return wThreat * hpFactor * (0.7 + speedFactor * 0.3) * (1 - (target.stats?.dodgeChance || 0) * 0.5);
    },
    fastMath: {
        hypotFast: (a, b) => {
            a = Math.abs(a); b = Math.abs(b);
            if (a < b) { const t = a; a = b; b = t; }
            if (a === 0) return 0;
            const ratio = b / a;
            return a * Math.sqrt(1 + ratio * ratio);
        },
        clampInline: (v, min, max) => v < min ? min : (v > max ? max : v),
        normalizeFast: (x, y) => {
            const lenSq = x*x + y*y;
            if (lenSq === 0) return { x: 0, y: 0 };
            const invLen = 1 / Math.sqrt(lenSq);
            return { x: x * invLen, y: y * invLen };
        }
    },
    safeMath: {
        hypot: (a, b) => {
            const result = Math.hypot(a, b);
            return isFinite(result) ? result : 0;
        },
        atan2: (y, x) => {
            const result = Math.atan2(y, x);
            return isFinite(result) ? result : 0;
        },
        divide: (a, b, fallback = 0) => {
            if (!isFinite(a) || !isFinite(b) || b === 0) return fallback;
            return a / b;
        },
        multiply: (a, b) => {
            const result = a * b;
            return isFinite(result) ? result : 0;
        }
    }
});

// ============================================================================
// SECTION 3: SEEDED RNG (DETERMINISTIC)
// ============================================================================

class SeededRNG {
    constructor(seed) {
        this._baseSeed = String(seed || 'default').split('').reduce((a, c, i) => {            return ((a * 31 + c.charCodeAt(0)) ^ (i * 17)) % 2147483647;
        }, String(seed || 'default').length) || 12345;
        this._state = this._baseSeed;
        this._callCount = 0;
    }
    next() {
        let x = this._state;
        x ^= x << 13;
        x ^= x >>> 17;
        x ^= x << 5;
        this._state = x >>> 0;
        this._callCount++;
        return (x * 0x2545F4914F6CDD1D) >>> 0 / 4294967296;
    }
    deriveWeights(rows, cols, scale) {
        const weights = [];
        for (let i = 0; i < rows; i++) {
            const row = new Float32Array(cols);
            for (let j = 0; j < cols; j++) {
                const hash = Utils.hashSeed(String(this._baseSeed), i * 1000 + j, 0);
                row[j] = (hash * 2 - 1) * scale;
            }
            weights.push(row);
        }
        return weights;
    }
    deriveVector(length, scale) {
        const vec = new Float32Array(length);
        for (let i = 0; i < length; i++) {
            const hash = Utils.hashSeed(String(this._baseSeed), i, 1000);
            vec[i] = (hash * 2 - 1) * scale;
        }
        return vec;
    }
    reset() { this._state = this._baseSeed; }
    getSeed() { return String(this._baseSeed); }
    getChecksum() {
        return this._state ^ (this._callCount * 0x12345678);
    }
    verify(expectedChecksum) {
        return this.getChecksum() === expectedChecksum;
    }
}

// ============================================================================
// SECTION 4: CORTEX-2 BRAIN (10/10 AUDITED)
// ============================================================================

class Cortex2Brain {
    constructor(config = {}) {        this.DIM = arenaConfig.CORTEX;
        this.seed = config.seed ?? arenaConfig.seed;
        this._rng = new SeededRNG(this.seed);
        this.lr = config.lr ?? arenaConfig.learningRate;
        this.gamma = config.gamma ?? arenaConfig.gamma;
        this.lambda = config.lambda ?? arenaConfig.lambda;
        this.hebbianRate = config.hebbianRate ?? arenaConfig.hebbianRate;

        this.W_P = this._initMatrix(400, this.DIM.DIM_P, 0.3);
        this.b_P = this._initVector(this.DIM.DIM_P, 0.1);

        this.W_A = [];
        this.b_A = [];
        for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
            this.W_A.push(this._initMatrix(160, this.DIM.HEAD_DIM, 0.3));
            this.b_A.push(this._initVector(this.DIM.HEAD_DIM, 0.1));
        }

        this.W_gate = this._initVector(this.DIM.NUM_HEADS, 0.25);
        this.W_reflex = this._initVector(4, 0.5);

        this.W_M_work = this._initMatrix(160, 48, 0.3);
        this.b_M_work = this._initVector(48, 0.1);
        this.W_M_perm = this._initMatrix(304, 48, 0.3);
        this.b_M_perm = this._initVector(48, 0.1);
        this.W_M_pred = this._initMatrix(192, 48, 0.3);
        this.b_M_pred = this._initVector(48, 0.1);

        this.W_C = this._initMatrix(289, this.DIM.DIM_C, 0.25);
        this.W_C = this._normalizeRecurrentWeights(this.W_C, 0.95);
        this.b_C = this._initVector(this.DIM.DIM_C, 0.1);

        this.W_S = this._initMatrix(128, this.DIM.DIM_S, 0.3);
        this.b_S = this._initVector(this.DIM.DIM_S, 0.1);
        this.W_D = this._initMatrix(336, this.DIM.DIM_D, 0.2);
        this.b_D = this._initVector(this.DIM.DIM_D, 0.1);

        this.W_pred = this._initMatrix(48, this.DIM.DIM_SENSOR, 0.15);
        this.b_pred = this._initVector(this.DIM.DIM_SENSOR, 0.05);

        this.W_V = this._initVector(this.DIM.DIM_C, 0.1);
        this.b_V = 0;

        this.P = new Float32Array(this.DIM.DIM_P);
        this.A = new Float32Array(this.DIM.DIM_A);
        this.M = new Float32Array(this.DIM.DIM_M);
        this.C = new Float32Array(this.DIM.DIM_C);
        this.S = new Float32Array(this.DIM.DIM_S);
        this.D = new Float32Array(this.DIM.DIM_D);
        this.P_prev = new Float32Array(this.DIM.DIM_P);
        this.A_prev = new Float32Array(this.DIM.DIM_A);
        this.M_prev = new Float32Array(this.DIM.DIM_M);
        this.C_prev = new Float32Array(this.DIM.DIM_C);
        this.S_prev = new Float32Array(this.DIM.DIM_S);
        this.D_prev = this._rng.deriveVector(this.DIM.DIM_D, 0.05);

        this._initEligibilityTraces();
        this.predictionErrors = new Float32Array(48);
        this.consolidationBuffer = [];
        this.maxBuffer = 32;

        this._stats = {
            tdErrorHistory: [],
            predictionErrorHistory: [],
            totalSteps: 0,
            avgReward: 0,
            kills: 0,
            deaths: 0,
            reflexTriggers: 0,
            consolidationEvents: 0,
            gradientClips: 0
        };

        this._lastInputs = null;
        this._lastOutputs = null;
        this._activeNeurons = [];
        this._attentionHeadNorms = null;

        this.emotions = {
            threat: 0, frustration: 0, confidence: 0, aggression: 0,
            fear: 0, surprise: 0, caution: 0, desperation: 0, vengeance: 0
        };

        this.emotionHistory = [];
        this.maxHistory = 30;

        this.emotionalState = {
            current: null,
            history: [],
            satisfaction: 0,
            momentum: {
                fear: 0, aggression: 0, frustration: 0,
                desperation: 0, confidence: 0, vengeance: 0
            }
        };

        this.emotionMemory = {
            trauma: 0, grudge: new Map(), lastEmotion: null,
            unresolved: 0, killer: null        };

        this.emotionConfig = {
            fear: { baseDuration: 180, intensityMultiplier: 2.0, satisfactionDecay: 0.02 },
            aggression: { baseDuration: 120, intensityMultiplier: 1.5, satisfactionDecay: 0.03 },
            frustration: { baseDuration: 240, intensityMultiplier: 2.5, satisfactionDecay: 0.01 },
            desperation: { baseDuration: 300, intensityMultiplier: 3.0, satisfactionDecay: 0.005 },
            confidence: { baseDuration: 150, intensityMultiplier: 1.2, satisfactionDecay: 0.04 },
            vengeance: { baseDuration: 360, intensityMultiplier: 3.5, satisfactionDecay: 0.003 }
        };

        this.emotionDecay = arenaConfig.EMOTION.DECAY_RATE;
        this.emotionInfluence = arenaConfig.EMOTION.INFLUENCE_WEIGHT;
        this.step = 0;
        this.cumulativeReward = 0;
        this.health = 100;
        this.stats = { maxHealth: 100 };
        this._lastKiller = null;
        
        this.predictedPos60 = { x: 0, y: 0 };
        this.predictionError60 = 0;
        this.predictedTrajectory = { angle: 0, confidence: 0 };
        
        this.W_key = this._initVector(32, 0.1);
    }

    _initMatrix(rows, cols, scale) {
        const mat = [];
        for (let i = 0; i < rows; i++) {
            const row = new Float32Array(cols);
            for (let j = 0; j < cols; j++) {
                const hash = Utils.hashSeed(this.seed, i * 10000 + j, 0);
                row[j] = (hash * 2 - 1) * scale;
            }
            mat.push(row);
        }
        return mat;
    }

    _initVector(length, scale) {
        const vec = new Float32Array(length);
        for (let i = 0; i < length; i++) {
            const hash = Utils.hashSeed(this.seed, i, 1000);
            vec[i] = (hash * 2 - 1) * scale;
        }
        return vec;
    }

    _normalizeRecurrentWeights(W, target_rho = 0.95) {
        let v = new Float32Array(W[0].length).fill(1);        for (let iter = 0; iter < 5; iter++) {
            let v_new = new Float32Array(W.length).fill(0);
            for (let i = 0; i < W.length; i++) {
                for (let j = 0; j < W[0].length; j++) {
                    v_new[i] += W[i][j] * v[j];
                }
            }
            const norm = Math.hypot(...v_new);
            if (norm < 1e-10) break;
            v = v_new.map(x => x / norm);
        }
        const Wv = new Float32Array(W.length);
        for (let i = 0; i < W.length; i++) {
            for (let j = 0; j < W[0].length; j++) {
                Wv[i] += W[i][j] * v[j];
            }
        }
        const estimated_rho = Math.hypot(...Wv);
        const factor = target_rho / (estimated_rho + 1e-8);
        for (let i = 0; i < W.length; i++) {
            for (let j = 0; j < W[0].length; j++) {
                W[i][j] *= factor;
            }
        }
        return W;
    }

    _initEligibilityTraces() {
        this.trace_P = new Float32Array(400 * this.DIM.DIM_P);
        this.trace_C = new Float32Array(289 * this.DIM.DIM_C);
        this.trace_D = new Float32Array(336 * this.DIM.DIM_D);
        this.trace_pred = new Float32Array(48 * this.DIM.DIM_SENSOR);
    }

    _estimateValue() {
        let sum = this.b_V;
        for (let i = 0; i < this.DIM.DIM_C; i++) {
            sum += this.C[i] * this.W_V[i];
        }
        return Utils.tanh(sum);
    }

    _updateValueHead(tdErr) {
        if (!arenaConfig.enableTraining) return;
        const alpha = this.lr * 0.5;
        for (let i = 0; i < this.DIM.DIM_C; i++) {
            this.W_V[i] += alpha * tdErr * this.C[i];
            this.W_V[i] = Utils.clamp(this.W_V[i], -2, 2);
        }
        this.b_V += alpha * tdErr;    }

    _buildPInput(x_t, C_prev, S_prev, M_perm_prev) {
        const input = new Float32Array(400);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_SENSOR; i++) input[idx++] = x_t[i];
        for (let i = 0; i < this.DIM.DIM_C; i++) input[idx++] = C_prev[i];
        for (let i = 0; i < this.DIM.DIM_S; i++) input[idx++] = S_prev[i];
        const key = Utils.linearMultiply(
            [...Array.from(x_t).slice(0, 16), ...Array.from(S_prev).slice(0, 16)],
            this.W_key, 'linear'
        );
        
        for (let i = 0; i < 48; i++) {
            let relevance = 0;
            for (let j = 0; j < 32; j++) {
                relevance += key[j] * M_perm_prev[i * 48 + j];
            }
            relevance = Utils.sigmoid(relevance);
            input[idx++] = M_perm_prev[i] * relevance;
        }
        return input;
    }

    _buildAInput(P_t, M_work, C_prev, D_prev, headIdx) {
        const input = new Float32Array(160);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_P; i++) input[idx++] = P_t[i];
        for (let i = 0; i < 48; i++) input[idx++] = M_work[i];
        const cStart = headIdx * 64;
        for (let i = 0; i < 64; i++) {
            const cIdx = cStart + i;
            input[idx++] = (cIdx < this.DIM.DIM_C) ? C_prev[cIdx] : 0;
        }
        for (let i = 0; i < this.DIM.DIM_D; i++) input[idx++] = D_prev[i];
        return input;
    }

    _buildMWorkInput(P_t, A_t, C_prev) {
        const input = new Float32Array(160);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_P; i++) input[idx++] = P_t[i];
        for (let i = 0; i < this.DIM.DIM_A; i++) input[idx++] = A_t[i];
        for (let i = 0; i < 64; i++) {
            input[idx++] = (i < this.DIM.DIM_C) ? C_prev[i] : 0;
        }
        return input;
    }

    _buildMPermInput(C_prev, M_perm_prev) {        const input = new Float32Array(304);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_C; i++) input[idx++] = C_prev[i];
        for (let i = 0; i < 48; i++) input[idx++] = M_perm_prev[i];
        return input;
    }

    _buildMPredInput(A_t, C_prev, M_work, D_prev) {
        const input = new Float32Array(192);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_A; i++) input[idx++] = A_t[i];
        for (let i = 0; i < 64; i++) {
            const cIdx = 192 + i;
            input[idx++] = (cIdx < this.DIM.DIM_C) ? C_prev[cIdx] : 0;
        }
        for (let i = 0; i < 48; i++) input[idx++] = M_work[i];
        for (let i = 0; i < this.DIM.DIM_D; i++) input[idx++] = D_prev[i];
        return input;
    }

    _buildCInput(P_t, A_t, M_t, S_prev, D_prev, r_t) {
        const input = new Float32Array(289);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_P; i++) input[idx++] = P_t[i];
        for (let i = 0; i < this.DIM.DIM_A; i++) input[idx++] = A_t[i];
        for (let i = 0; i < this.DIM.DIM_M; i++) input[idx++] = M_t[i];
        for (let i = 0; i < this.DIM.DIM_S; i++) input[idx++] = S_prev[i];
        for (let i = 0; i < this.DIM.DIM_D; i++) input[idx++] = D_prev[i];
        input[idx] = Utils.clamp(r_t / 50.0, -2, 2);
        return input;
    }

    _buildSInput(P_t, M_perm, C_prev, D_prev) {
        const input = new Float32Array(128);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_P; i++) input[idx++] = P_t[i];
        for (let i = 0; i < 48; i++) input[idx++] = M_perm[i];
        for (let i = 0; i < 32; i++) {
            const cIdx = 224 + i;
            input[idx++] = (cIdx < this.DIM.DIM_C) ? C_prev[cIdx] : 0;
        }
        for (let i = 0; i < this.DIM.DIM_D; i++) input[idx++] = D_prev[i];
        return input;
    }

    _buildDInput(C_t, S_t, M_pred) {
        const input = new Float32Array(336);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_C; i++) input[idx++] = C_t[i];
        for (let i = 0; i < this.DIM.DIM_S; i++) input[idx++] = S_t[i];        for (let i = 0; i < 48; i++) input[idx++] = M_pred[i];
        return input;
    }

    _getMWork(M) { return M.slice(this.DIM.M_WORK_START, this.DIM.M_WORK_END); }
    _getMPerm(M) { return M.slice(this.DIM.M_PERM_START, this.DIM.M_PERM_END); }
    _getMPred(M) { return M.slice(this.DIM.M_PRED_START, this.DIM.M_PRED_END); }
    _updatePrediction(M_pred, x_t) {
        const x_pred = Utils.linearMultiply(M_pred, this.W_pred);
        for (let i = 0; i < this.DIM.DIM_SENSOR; i++) {
            x_pred[i] += this.b_pred[i];
        }
        
        for (let i = 0; i < 48; i++) {
            const error = Math.abs(x_pred[i] - x_t[i]);
            this.predictionErrors[i] = Utils.lerp(this.predictionErrors[i], error, 0.1);
        }
        
        const enemyVx = x_t[4] || 0;
        const enemyVy = x_t[5] || 0;
        
        this.predictedPos60 = {
            x: x_t[0] + enemyVx * 60,
            y: x_t[1] + enemyVy * 60
        };
        
        this.predictedPos120 = {
            x: x_t[0] + enemyVx * 120,
            y: x_t[1] + enemyVy * 120
        };
        
        this.predictedPos240 = {
            x: x_t[0] + enemyVx * 240,
            y: x_t[1] + enemyVy * 240
        };
        
        const actualX = this._lastInputs?.x_t[0] || x_t[0];
        const actualY = this._lastInputs?.x_t[1] || x_t[1];
        this.predictionError60 = Math.abs(this.predictedPos60.x - actualX) + 
                                  Math.abs(this.predictedPos60.y - actualY);
        
        const predictedAngle = Math.atan2(this.predictedPos60.y - actualY, this.predictedPos60.x - actualX);
        const confidence = 1 - Utils.clamp(this.predictionError60 / 100, 0, 1);
        this.predictedTrajectory = { angle: predictedAngle, confidence: confidence };
        
        if (arenaConfig.enableTraining) {
            const lr = this.lr * 0.1;
            for (let i = 0; i < 48; i++) {
                for (let j = 0; j < this.DIM.DIM_SENSOR; j++) {
                    this.W_pred[i][j] += lr * (x_t[j] - x_pred[j]) * M_pred[i];                    this.W_pred[i][j] = Utils.clamp(this.W_pred[i][j], -2, 2);
                }
            }
        }
    }

    _computeAvgPredError() {
        let sum = 0;
        for (let i = 0; i < 48; i++) sum += this.predictionErrors[i];
        return sum / 48;
    }

    _checkReflexPath(x_t, S_new, D_new) {
        const emotionModulator = this.emotionInfluence;
        if (S_new[8] > 0.6) {
            this._stats.reflexTriggers++;
            D_new[6] = Utils.lerp(D_new[6], Math.min(1, D_new[6] + 0.4), emotionModulator);
            D_new[4] = Utils.lerp(D_new[4], Math.min(1, D_new[4] + 0.3), emotionModulator);
        }
        if (S_new[7] > 0.6) {
            this._stats.reflexTriggers++;
            D_new[6] = Utils.lerp(D_new[6], Math.min(1, D_new[6] + 0.35), emotionModulator);
            D_new[4] = Utils.lerp(D_new[4], Math.min(1, D_new[4] + 0.3), emotionModulator);
        }
        if (S_new[4] > 0.7) {
            this._stats.reflexTriggers++;
            D_new[10] = Utils.lerp(D_new[10], Math.min(1, D_new[10] + 0.35), emotionModulator);
            D_new[4] = Utils.lerp(D_new[4], Math.max(0, D_new[4] - 0.2), emotionModulator);
        }
        if (S_new[1] > 0.7) {
            this._stats.reflexTriggers++;
            D_new[6] = Utils.lerp(D_new[6], Math.min(1, D_new[6] + 0.3), emotionModulator);
            D_new[4] = Utils.lerp(D_new[4], Math.min(1, D_new[4] + 0.25), emotionModulator);
        }
        if (S_new[2] > 0.6) {
            D_new[11] = Utils.lerp(D_new[11], Math.min(1, D_new[11] + 0.25), emotionModulator);
        }
    }

    _resolveCommandConflicts(D_new, emotions, mentalContext = {}) {
        const influence = this.emotionInfluence;
        if (emotions.vengeance > 0.5 || emotions.desperation > 0.5) {
            D_new[4] = Utils.lerp(D_new[4], Math.min(1, D_new[4] + 0.3), influence);
        }
        if (emotions.confidence > 0.6 && (mentalContext.alliesNearby || 0) > 1) {
            D_new[5] = Utils.lerp(D_new[5], Math.min(1, D_new[5] + 0.4), influence);
        }
        if (emotions.fear > 0.7 && (mentalContext.selfHP || 1) < 0.3) {
            D_new[6] = Utils.lerp(D_new[6], Math.min(1, D_new[6] + 0.5), influence);
            D_new[4] = Math.max(0, D_new[4] - 0.2);        }
        if ((mentalContext.teamAdvantage || 0) > 0.7) {
            D_new[7] = Utils.lerp(D_new[7], 0.8, influence * 0.5);
        }
        if (D_new[6] > 0.7) D_new[4] = Math.min(D_new[4], 0.3);
    }
    _selectActiveNeurons() {
        const all = [];
        const addTop = (arr, offset, count) => {
            const indexed = [];
            for (let i = 0; i < arr.length; i++) {
                indexed.push({ i: offset + i, v: Math.abs(Utils.safeNumber(arr[i], 0)) });
            }
            indexed.sort((a, b) => b.v - a.v);
            for (let i = 0; i < Math.min(count, indexed.length); i++) {
                all.push(indexed[i]);
            }
        };
        addTop(this.P, 0, 2);
        addTop(this.A, 32, 2);
        addTop(this.M.slice(96, 144), 96, 1);
        return all.slice(0, 5).map(n => n.i);
    }

    _computeAttentionHeadNorms() {
        const norms = [];
        for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
            let sum = 0;
            for (let i = 0; i < this.DIM.HEAD_DIM; i++) {
                sum += Math.abs(this.A[h * this.DIM.HEAD_DIM + i]);
            }
            norms.push(sum / this.DIM.HEAD_DIM);
        }
        return norms;
    }

    _getDominantEmotion() {
        const emotions = [
            { name: 'vengeance', value: this.emotions.vengeance },
            { name: 'desperation', value: this.emotions.desperation },
            { name: 'fear', value: this.emotions.fear },
            { name: 'aggression', value: this.emotions.aggression },
            { name: 'frustration', value: this.emotions.frustration },
            { name: 'confidence', value: this.emotions.confidence }
        ];
        emotions.sort((a, b) => b.value - a.value);
        return { name: emotions[0].name, intensity: emotions[0].value };
    }

    _enterEmotion(name, intensity) {        const config = this.emotionConfig[name];
        if (!config) return;
        if (this.emotionalState.current) {
            this.emotionalState.history.push({
                ...this.emotionalState.current,
                endStep: this.step,
                reason: 'transition'
            });
            if (this.emotionalState.history.length > 5) {
                this.emotionalState.history.shift();
            }
        }
        this.emotionalState.current = {
            name, intensity, initialIntensity: intensity,
            baseDuration: config.baseDuration,
            remainingFrames: Math.floor(config.baseDuration * intensity * config.intensityMultiplier),
            satisfaction: this.emotionalState.satisfaction,
            startStep: this.step
        };
    }

    _exitEmotion(state, reason = 'completed') {
        this.emotionalState.history.push({
            ...state, endStep: this.step, reason
        });
        if (this.emotionalState.history.length > 5) {
            this.emotionalState.history.shift();
        }
        this.emotionMemory.lastEmotion = {
            name: state.name, intensity: state.intensity,
            satisfaction: state.satisfaction,
            completed: reason === 'completed' || reason === 'satisfied'
        };
        if (reason === 'transition' || reason === 'interrupted') {
            this.emotionMemory.unresolved = Utils.clamp(this.emotionMemory.unresolved + state.intensity * 0.5, 0, 1);
        }
        this.emotionalState.current = null;
    }

    _canExitEmotion(state) {
        if (state.remainingFrames < state.baseDuration * 0.3) return false;
        if (state.satisfaction > 0.6) return true;
        if (state.intensity < 0.3) return true;
        return false;
    }

    _shouldExtendEmotion(state) {
        if (state.intensity > state.initialIntensity + 0.2) return true;
        if (state.satisfaction < -0.3) return true;
        return false;    }

    _checkEmotionTransition(state) {
        const current = state.name;
        if (current === 'fear' && this.emotions.desperation > 0.7) {
            return { name: 'desperation', intensity: this.emotions.desperation };
        }
        if (current === 'frustration' && this.emotions.aggression > 0.6) {
            return { name: 'aggression', intensity: this.emotions.aggression };
        }
        if (current === 'aggression' && state.satisfaction < -0.5) {
            return { name: 'frustration', intensity: this.emotions.frustration };
        }
        if (current === 'desperation' && state.intensity < 0.4) {
            return { name: 'fear', intensity: this.emotions.fear };
        }
        if (current === 'vengeance' && state.satisfaction > 0.5) {
            return { name: 'confidence', intensity: this.emotions.confidence };
        }
        return null;
    }

    _processCombatEvents(events) {
        if (!events) return;
        for (const event of events) {
            switch(event.type) {
                case 'hit_dealt':
                    this.emotionalState.satisfaction = Utils.clamp(this.emotionalState.satisfaction + 0.15, -1, 1);
                    if (this.emotionalState.current?.name === 'aggression' || this.emotionalState.current?.name === 'vengeance') {
                        this.emotionalState.current.intensity = Math.min(1, this.emotionalState.current.intensity + 0.05);
                    }
                    if (this.emotionalState.current?.name === 'vengeance') {
                        this.emotionalState.satisfaction = Utils.clamp(this.emotionalState.satisfaction + 0.1, -1, 1);
                    }
                    break;
                case 'hit_missed':
                    this.emotions.frustration = Math.min(1, this.emotions.frustration + 0.1);
                    this.emotionalState.satisfaction = Utils.clamp(this.emotionalState.satisfaction - 0.1, -1, 1);
                    break;
                case 'damage_received':
                    this.emotions.fear = Math.min(1, this.emotions.fear + (event.damage || 1) * 0.02);
                    this.emotionalState.satisfaction = Utils.clamp(this.emotionalState.satisfaction - 0.2, -1, 1);
                    if (this.health / this.stats.maxHealth < 0.3) {
                        this.emotions.desperation = Math.min(1, this.emotions.desperation + 0.15);
                    }
                    if (event.attacker && this.emotionalState.current?.name === 'vengeance') {
                        const grudge = this.emotionMemory.grudge.get(event.attacker) || 0;
                        this.emotionMemory.grudge.set(event.attacker, Utils.clamp(grudge + 0.1, -1, 1));
                    }
                    break;                case 'enemy_defeated':
                    this.emotions.confidence = Math.min(1, this.emotions.confidence + 0.3);
                    this.emotionalState.satisfaction = Utils.clamp(this.emotionalState.satisfaction + 0.5, -1, 1);
                    if (this.emotionalState.current?.name === 'aggression' || this.emotionalState.current?.name === 'vengeance') {
                        this._exitEmotion(this.emotionalState.current, 'satisfied');
                    }
                    if (event.target === this.emotionMemory.killer) {
                        this.emotions.vengeance = 0;
                        this.emotionMemory.killer = null;
                        this.emotionMemory.grudge.delete(event.target);
                    }
                    break;
                case 'killed_by':
                    if (event.killer) {
                        this.emotionMemory.killer = event.killer;
                        const grudge = this.emotionMemory.grudge.get(event.killer) || 0;
                        this.emotionMemory.grudge.set(event.killer, Utils.clamp(grudge + 0.5, -1, 1));
                        this.emotions.vengeance = Math.min(1, this.emotions.vengeance + 0.6);
                    }
                    break;
            }
        }
    }

    _updateEmotions(r_t, x_t, combatEvents = null) {
        this.step++;
        this.emotionHistory.push({ ...this.emotions, step: this.step });
        if (this.emotionHistory.length > this.maxHistory) {
            this.emotionHistory.shift();
        }
        if (combatEvents) {
            this._processCombatEvents(combatEvents);
        }
        if (this.emotionalState.current) {
            const state = this.emotionalState.current;
            const config = this.emotionConfig[state.name];
            state.remainingFrames--;
            state.satisfaction = Utils.lerp(state.satisfaction, this.emotionalState.satisfaction, 0.1);
            if (this._canExitEmotion(state)) {
                this._exitEmotion(state);
            }
            if (this._shouldExtendEmotion(state)) {
                state.remainingFrames = Math.min(state.remainingFrames + 30, config.baseDuration * 3);
            }
            const transition = this._checkEmotionTransition(state);
            if (transition) {
                this._enterEmotion(transition.name, transition.intensity);
            }
        } else {
            const dominant = this._getDominantEmotion();            if (dominant.intensity > 0.7) {
                this._enterEmotion(dominant.name, dominant.intensity);
            }
        }
        if (r_t < 0.1) {
            this.emotions.frustration = Math.min(1, this.emotions.frustration + 0.03);
        } else {
            this.emotions.frustration *= 0.92;
        }
        const normalizedReward = Utils.clamp((this.cumulativeReward + 100) / 200, 0, 1);
        if (normalizedReward < 0.3) {
            this.emotions.desperation = Math.min(1, this.emotions.desperation + 0.05);
        } else {
            this.emotions.desperation *= 0.85;
        }
        if (r_t > 1) {
            this.emotions.confidence = Math.min(1, this.emotions.confidence + 0.05);
        } else {
            this.emotions.confidence *= 0.95;
        }
        if (r_t < -0.5) {
            this.emotions.fear = Math.min(1, this.emotions.fear + 0.1);
        } else {
            this.emotions.fear *= 0.85;
        }
        const avgPredError = this._computeAvgPredError();
        this.emotions.surprise = avgPredError;
        const healthInput = x_t[12] ?? 0.5;
        this.emotions.caution = 1 - healthInput;
        const distanceInput = x_t[2] ?? 0.5;
        this.emotions.threat = 1 - distanceInput;
        const recentFrames = Math.min(10, this.emotionHistory.length);
        if (recentFrames > 0) {
            const recent = this.emotionHistory.slice(-recentFrames);
            this.emotionalState.momentum.fear = recent.reduce((s, e) => s + e.fear, 0) / recentFrames;
            this.emotionalState.momentum.aggression = recent.reduce((s, e) => s + e.aggression, 0) / recentFrames;
            this.emotionalState.momentum.frustration = recent.reduce((s, e) => s + e.frustration, 0) / recentFrames;
            this.emotionalState.momentum.desperation = recent.reduce((s, e) => s + e.desperation, 0) / recentFrames;
            this.emotionalState.momentum.confidence = recent.reduce((s, e) => s + e.confidence, 0) / recentFrames;
            this.emotionalState.momentum.vengeance = recent.reduce((s, e) => s + e.vengeance, 0) / recentFrames;
        }
        const fearBlock = (1 - this.emotions.desperation) * this.emotionalState.momentum.fear;
        this.emotions.aggression =
            this.emotionalState.momentum.frustration * 0.6 +
            this.emotionalState.momentum.desperation * 0.8 +
            this.emotionalState.momentum.vengeance * 0.9 -
            fearBlock * 0.4;
        this.S[0] = this.emotions.threat;
        this.S[1] = this.emotions.frustration;
        this.S[2] = this.emotions.confidence;        this.S[3] = this.emotions.aggression;
        this.S[4] = this.emotions.fear;
        this.S[5] = this.emotions.surprise;
        this.S[6] = this.emotions.caution;
        this.S[7] = this.emotions.desperation;
        this.S[8] = this.emotions.vengeance;
        for (const key of Object.keys(this.emotions)) {
            this.emotions[key] *= this.emotionDecay;
        }
        this._lastReward = r_t;
    }

    storeEmotionalMemory() {
        this.emotionMemory = {
            trauma: this.emotionMemory.trauma + (this.emotions.fear * 0.3),
            grudge: new Map(this.emotionMemory.grudge),
            lastEmotion: this.emotionalState.current ? { ...this.emotionalState.current } : this.emotionMemory.lastEmotion,
            unresolved: this.emotionMemory.unresolved,
            killer: this._lastKiller,
            timestamp: Date.now()
        };
    }

    restoreEmotionalMemory() {
        if (!this.emotionMemory || !this.emotionMemory.lastEmotion) return;
        const memory = this.emotionMemory;
        this.emotions.fear = Math.min(1, memory.trauma * 0.5);
        this.emotions.vengeance = memory.grudge.size > 0 ? 0.5 : 0;
        if (memory.lastEmotion.name === 'vengeance' && !memory.lastEmotion.completed) {
            this.emotions.vengeance = memory.lastEmotion.intensity * 0.7;
            this.emotions.aggression = memory.lastEmotion.intensity * 0.5;
        }
        if (memory.killer) {
            const grudge = memory.grudge.get(memory.killer) || 0;
            if (grudge > 0.3) {
                this.emotions.vengeance = Math.max(this.emotions.vengeance, grudge);
            }
        }
        this.emotionMemory.trauma *= arenaConfig.EMOTION.TRAUMA_DECAY;
        this.emotionMemory.unresolved *= 0.7;
        for (const [killerId, grudge] of this.emotionMemory.grudge) {
            this.emotionMemory.grudge.set(killerId, grudge * arenaConfig.EMOTION.GRUDGE_DECAY);
        }
    }

    _applyMotorConstraints(D_raw) {
        const D = new Float32Array(16);
        
        D[0] = Utils.sigmoid(D_raw[0]);
        D[1] = Utils.tanh(D_raw[1]);        D[2] = Utils.sigmoid(D_raw[2]);
        D[3] = Utils.sigmoid(D_raw[3]);
        
        const aggression = Utils.sigmoid(D_raw[4]);
        const defense = Utils.sigmoid(D_raw[6]);
        const confidence = Utils.sigmoid(D_raw[8]);
        D[2] = D[2] * (0.5 + 0.5 * aggression) * (0.7 + 0.3 * confidence);
        D[0] = D[0] * (1 - 0.3 * defense);
        
        for (let i = 4; i < 16; i++) {
            D[i] = Utils.sigmoid(D_raw[i]);
        }
        
        return D;
    }

    _calculateIntrinsicReward(x_t, x_pred) {
        const novelty = Math.hypot(...Array.from(x_t).map((v, i) => v - x_pred[i])) / x_t.length;
        const curiosity_reward = novelty * Math.exp(-novelty);
        return curiosity_reward * 0.1;
    }

    forward(rawInputs, reward = 0, combatEvents = null) {
        const safeInputs = rawInputs || new Array(64).fill(0);
        const x_t = Utils.projectToCortexSensors(safeInputs, { DIM_SENSOR: this.DIM.DIM_SENSOR, seed: this.seed });
        const r_t = Utils.safeNumber(reward, 0);
        this._lastInputs = { x_t: Array.from(x_t), r_t };
        this.cumulativeReward = Utils.lerp(this.cumulativeReward, r_t, 0.1);
        const P_input = this._buildPInput(x_t, this.C_prev, this.S_prev, this._getMPerm(this.M_prev));
        const A_inputs = [];
        for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
            A_inputs.push(this._buildAInput(this.P_prev, this._getMWork(this.M_prev), this.C_prev, this.D_prev, h));
        }
        const M_work_input = this._buildMWorkInput(this.P_prev, this.A_prev, this.C_prev);
        const M_perm_input = this._buildMPermInput(this.C_prev, this._getMPerm(this.M_prev));
        const M_pred_input = this._buildMPredInput(this.P_prev, this.C_prev, this._getMWork(this.M_prev), this.D_prev);
        const C_input = this._buildCInput(this.P_prev, this.A_prev, this.M_prev, this.S_prev, this.D_prev, r_t);
        const S_input = this._buildSInput(this.P_prev, this._getMPerm(this.M_prev), this.C_prev, this.D_prev);
        const D_input = this._buildDInput(this.C_prev, this.S_prev, this._getMPred(this.M_prev));
        const P_new = Utils.matrixMultiply(P_input, this.W_P, 'relu');
        for (let i = 0; i < this.DIM.DIM_P; i++) P_new[i] = Utils.leakyRelu(P_new[i] + this.b_P[i]);
        const A_new = new Float32Array(this.DIM.DIM_A);
        const gateProbs = Utils.softmax(this.W_gate, 1.0);
        for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
            const headOut = Utils.matrixMultiply(A_inputs[h], this.W_A[h], 'relu');
            const gateWeight = gateProbs[h];
            for (let i = 0; i < this.DIM.HEAD_DIM; i++) {
                A_new[h * this.DIM.HEAD_DIM + i] = Utils.leakyRelu(headOut[i] + this.b_A[h][i]) * gateWeight;
            }
        }        const M_work_new = Utils.matrixMultiply(M_work_input, this.W_M_work, 'relu');
        for (let i = 0; i < 48; i++) M_work_new[i] = Utils.leakyRelu(M_work_new[i] + this.b_M_work[i]);
        const M_perm_new = Utils.matrixMultiply(M_perm_input, this.W_M_perm, 'relu');
        for (let i = 0; i < 48; i++) M_perm_new[i] = Utils.leakyRelu(M_perm_new[i] + this.b_M_perm[i]);
        const M_pred_new = Utils.matrixMultiply(M_pred_input, this.W_M_pred, 'relu');
        for (let i = 0; i < 48; i++) M_pred_new[i] = Utils.leakyRelu(M_pred_new[i] + this.b_M_pred[i]);
        const M_new = new Float32Array(this.DIM.DIM_M);
        for (let i = 0; i < 48; i++) M_new[i] = M_work_new[i];
        for (let i = 0; i < 48; i++) M_new[48 + i] = M_perm_new[i];
        for (let i = 0; i < 48; i++) M_new[96 + i] = M_pred_new[i];
        const C_new = Utils.matrixMultiply(C_input, this.W_C, 'relu');
        for (let i = 0; i < this.DIM.DIM_C; i++) C_new[i] = Utils.leakyRelu(C_new[i] + this.b_C[i]);
        const S_new = Utils.matrixMultiply(S_input, this.W_S, 'relu');
        for (let i = 0; i < this.DIM.DIM_S; i++) S_new[i] = Utils.leakyRelu(S_new[i] + this.b_S[i]);
        const D_new = Utils.matrixMultiply(D_input, this.W_D, 'tanh');
        for (let i = 0; i < this.DIM.DIM_D; i++) D_new[i] = Utils.tanh(D_new[i] + this.b_D[i]);
        this.P_prev.set(this.P); this.A_prev.set(this.A); this.M_prev.set(this.M);
        this.C_prev.set(this.C); this.S_prev.set(this.S); this.D_prev.set(this.D);
        this.P.set(P_new); this.A.set(A_new); this.M.set(M_new);
        this.C.set(C_new); this.S.set(S_new); this.D.set(D_new);
        
        this._updatePrediction(M_pred_new, x_t);
        
        const x_pred = Utils.linearMultiply(M_pred_new, this.W_pred);
        for (let i = 0; i < this.DIM.DIM_SENSOR; i++) {
            x_pred[i] += this.b_pred[i];
        }
        
        const predError = this._computeAvgPredError();
        const predConfidence = 1 - Utils.clamp(predError / 0.5, 0, 1);
        D_new[8] = Utils.lerp(D_new[8], predConfidence, 0.15);
        
        const predDx = x_pred[0] - x_t[0];
        const predDy = x_pred[1] - x_t[1];
        const predAngle = Math.atan2(predDy, predDx);
        const desiredTrajectory = Utils.normalizeAngle(predAngle) / Math.PI;
        
        const pred_uncertainty = Utils.clamp(this.predictionError60 / 50.0, 0, 1);
        const trust = 1 - pred_uncertainty;
        const lerp_coef = 0.05 + 0.15 * trust;
        D_new[9] = Utils.lerp(D_new[9], desiredTrajectory, lerp_coef);
        
        this._updateEmotions(r_t, x_t, combatEvents);
        if (arenaConfig.enableReflexPath) {
            this._checkReflexPath(x_t, S_new, D_new);
            this._resolveCommandConflicts(D_new, this.emotions);
        }
        this._activeNeurons = this._selectActiveNeurons();
        this._attentionHeadNorms = this._computeAttentionHeadNorms();
                const D_constrained = this._applyMotorConstraints(D_new);
        
        return {
            output: Array.from(D_constrained),
            cortex: Array.from(this.C),
            predictionError: this._computeAvgPredError(),
            predictionError60: this.predictionError60,
            predictedPos60: { ...this.predictedPos60 },
            predictedTrajectory: { ...this.predictedTrajectory },
            reflexTriggered: this.S.some(v => v > 0.9),
            emotions: { ...this.emotions },
            emotionalState: this.emotionalState.current ? { ...this.emotionalState.current } : null,
            intrinsicReward: this._calculateIntrinsicReward(x_t, x_pred)
        };
    }

    tdLearn(inputs, outputs, reward, value, nextValue, actionLogProbs = null) {
        const currentValue = value !== undefined && value !== null ? Utils.safeNumber(value, 0) : this._estimateValue();
        const nextVal = nextValue !== undefined && nextValue !== null ? Utils.safeNumber(nextValue, 0) : this._estimateValue();
        let tdErr = Utils.tdError(reward, currentValue, nextVal, this.gamma);
        
        const avgPredError = this._computeAvgPredError();
        if (avgPredError > 0.5) {
            tdErr *= 1.5;
        } else if (avgPredError < 0.2) {
            tdErr *= 0.8;
        }
        
        this._stats.tdErrorHistory.push(Math.abs(tdErr));
        if (this._stats.tdErrorHistory.length > 100) this._stats.tdErrorHistory.shift();
        this._updateValueHead(tdErr);
        this._updateEligibilityTraces(inputs, outputs, tdErr);
        this._applyTDError(tdErr, 'td');
        if (arenaConfig.enableTraining && actionLogProbs?.length) {
            const avgAdvantage = -actionLogProbs.reduce((a,b) => a+b, 0) / actionLogProbs.length;
            for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
                this.W_gate[h] += this.lr * 0.3 * avgAdvantage * (this._attentionHeadNorms?.[h] || 0.25);
                this.W_gate[h] = Utils.clamp(this.W_gate[h], -2, 2);
            }
        }
        if (arenaConfig.enableConsolidation && reward > 3) this._consolidateMemories(reward);
        if (arenaConfig.enableHebbian && reward > 1) {
            const rewardMagnitude = Utils.clamp(Math.abs(reward) / 5.0, 0, 1);
            const correlation = Math.sign(reward) * (0.5 + 0.5 * rewardMagnitude);
            this._hebbianUpdate(this.P_prev, this.A_prev, correlation, 'P‚ÜíA', 'hebbian');
            this._hebbianUpdate(this.A_prev, this.C_prev, correlation, 'A‚ÜíC', 'hebbian');
            this._hebbianUpdate(this.C_prev, this.D_prev, correlation, 'C‚ÜíD', 'hebbian');
        }
        this._stats.totalSteps++;
        this._stats.avgReward = Utils.lerp(this._stats.avgReward, reward, 0.01);        return {
            tdError: tdErr,
            avgTDError: this._stats.tdErrorHistory.reduce((a,b)=>a+b,0)/Math.max(1,this._stats.tdErrorHistory?.length || 1),
            avgPredictionError: this._computeAvgPredError(),
            predictionError60: this.predictionError60
        };
    }

    _updateEligibilityTraces(inputs, outputs, tdErr) {
        const decay = this.gamma * this.lambda;
        for (let i = 0; i < 400; i++) {
            for (let j = 0; j < this.DIM.DIM_P; j++) {
                const idx = i * this.DIM.DIM_P + j;
                this.trace_P[idx] = decay * this.trace_P[idx] + inputs[i] * this.P[j];
                this.trace_P[idx] = Utils.clamp(this.trace_P[idx], -10, 10);
            }
        }
        for (let i = 0; i < 289; i++) {
            for (let j = 0; j < this.DIM.DIM_C; j++) {
                const idx = i * this.DIM.DIM_C + j;
                this.trace_C[idx] = decay * this.trace_C[idx] + inputs[i] * this.C[j];
                this.trace_C[idx] = Utils.clamp(this.trace_C[idx], -10, 10);
            }
        }
        for (let i = 0; i < 336; i++) {
            for (let j = 0; j < this.DIM.DIM_D; j++) {
                const idx = i * this.DIM.DIM_D + j;
                this.trace_D[idx] = decay * this.trace_D[idx] + inputs[i] * this.D[j];
                this.trace_D[idx] = Utils.clamp(this.trace_D[idx], -10, 10);
            }
        }
    }

    _applyTDError(tdErr, errorType = 'td') {
        const alpha = this.lr * Math.sign(tdErr) * 0.1;
        const MAX_GRAD = 0.3;
        const affectedSubsystems = this._getAffectedSubsystems(errorType);
        for (const sub of affectedSubsystems) {
            const subAlpha = alpha * sub.lr;
            for (let i = sub.start; i < sub.end; i++) {
                for (let j = 0; j < 289; j++) {
                    if (this.W_C[j] && this.W_C[j][i] !== undefined) {
                        const delta = Utils.clamp(subAlpha * this.trace_C[j * this.DIM.DIM_C + i], -MAX_GRAD, MAX_GRAD);
                        this.W_C[j][i] += delta;
                        this.W_C[j][i] = Utils.clamp(this.W_C[j][i], -2, 2);
                    }
                }
            }
        }
    }
    _getAffectedSubsystems(errorType) {
        const map = {
            'td': [{ start: 64, end: 128, lr: 0.01 }, { start: 128, end: 192, lr: 0.03 }],
            'prediction': [{ start: 0, end: 64, lr: 0.10 }],
            'emotion': [{ start: 192, end: 256, lr: 0.001 }],
            'hebbian': [{ start: 0, end: 64, lr: 0.10 }, { start: 64, end: 128, lr: 0.01 }]
        };
        return map[errorType] || [{ start: 64, end: 128, lr: 0.01 }];
    }

    _hebbianUpdate(pre, post, correlation, label, errorType = 'hebbian') {
        if (!arenaConfig.enableHebbian || !pre?.length || !post?.length) return;
        const eta = this.hebbianRate * correlation * 0.5;
        const step = Math.max(1, Math.floor(pre.length / 50));
        for (let i = 0; i < post.length; i += step) {
            for (let j = 0; j < pre.length; j += step) {
                const delta = eta * pre[j] * post[i];
                if (label === 'P‚ÜíA' && i < this.DIM.DIM_A) {
                    const headIdx = Math.floor(i / this.DIM.HEAD_DIM);
                    const localI = i % this.DIM.HEAD_DIM;
                    if (j < 160 && this.W_A[headIdx] && this.W_A[headIdx][j] && this.W_A[headIdx][j][localI] !== undefined) {
                        this.W_A[headIdx][j][localI] += delta;
                        this.W_A[headIdx][j][localI] = Utils.clamp(this.W_A[headIdx][j][localI], -2, 2);
                    }
                } else if (label === 'A‚ÜíC' && i < this.DIM.DIM_C) {
                    const weightRow = 32 + j;
                    if (weightRow < 289 && this.W_C[weightRow] && this.W_C[weightRow][i] !== undefined) {
                        this.W_C[weightRow][i] += delta;
                        this.W_C[weightRow][i] = Utils.clamp(this.W_C[weightRow][i], -2, 2);
                    }
                } else if (label === 'C‚ÜíD' && i < this.DIM.DIM_D) {
                    if (j < 336 && this.W_D[j] && this.W_D[j][i] !== undefined) {
                        this.W_D[j][i] += delta;
                        this.W_D[j][i] = Utils.clamp(this.W_D[j][i], -2, 2);
                    }
                }
            }
        }
    }

    _consolidateMemories(reward) {
        for (let i = 0; i < 48; i++) {
            if (this.predictionErrors[i] > 0.25) {
                this.consolidationBuffer.push({
                    idx: i, value: this.M[96 + i], priority: this.predictionErrors[i] * reward
                });
            }
        }
        if (this.consolidationBuffer.length > 0 && this._rng.next() < 0.1) {            const total = this.consolidationBuffer.reduce((s, x) => s + x.priority, 0);
            if (total <= 0) return;
            let rand = this._rng.next() * total;
            let selected = this.consolidationBuffer[0];
            for (const item of this.consolidationBuffer) {
                rand -= item.priority;
                if (rand <= 0) { selected = item; break; }
            }
            this.M[48 + selected.idx] = Utils.lerp(this.M[48 + selected.idx], selected.value, 0.2);
            this._stats.consolidationEvents++;
            const idx = this.consolidationBuffer.indexOf(selected);
            if (idx >= 0) this.consolidationBuffer.splice(idx, 1);
        }
        if (this.consolidationBuffer.length > this.maxBuffer) {
            this.consolidationBuffer.sort((a, b) => b.priority - a.priority);
            this.consolidationBuffer.length = this.maxBuffer;
        }
    }

    mutate(rate = 0.1, strength = 0.1) {
        if (!arenaConfig.enableEvolution) return 0;
        let mutations = 0;
        const mutateMat = (mat) => {
            if (!mat?.length) return;
            for (let i = 0; i < mat.length; i++) {
                if (!mat[i]?.length) continue;
                for (let j = 0; j < mat[i].length; j++) {
                    if (this._rng.next() < rate) {
                        mat[i][j] += (this._rng.next() * 2 - 1) * strength;
                        mat[i][j] = Utils.clamp(mat[i][j], -2, 2);
                        mutations++;
                    }
                }
            }
        };
        mutateMat(this.W_P); mutateMat(this.W_C); mutateMat(this.W_D);
        for (const W of this.W_A) mutateMat(W);
        mutateMat(this.W_M_work); mutateMat(this.W_M_perm); mutateMat(this.W_M_pred);
        mutateMat(this.W_S); mutateMat(this.W_pred);
        for (let i = 0; i < this.W_gate.length; i++) {
            if (this._rng.next() < rate) {
                this.W_gate[i] += (this._rng.next() * 2 - 1) * strength;
                this.W_gate[i] = Utils.clamp(this.W_gate[i], -2, 2);
                mutations++;
            }
        }
        for (let i = 0; i < this.W_reflex.length; i++) {
            if (this._rng.next() < rate) {
                this.W_reflex[i] += (this._rng.next() * 2 - 1) * strength;
                this.W_reflex[i] = Utils.clamp(this.W_reflex[i], -2, 2);                mutations++;
            }
        }
        return mutations;
    }
    clone() {
        const clone = new Cortex2Brain({
            seed: this.seed + '_clone_' + Date.now(),
            lr: this.lr, gamma: this.gamma, lambda: this.lambda
        });
        const copyMat = (src) => src.map(r => new Float32Array(r));
        clone.W_P = copyMat(this.W_P); clone.b_P = new Float32Array(this.b_P);
        clone.W_A = this.W_A.map(copyMat); clone.b_A = this.b_A.map(b => new Float32Array(b));
        clone.W_gate = new Float32Array(this.W_gate); clone.W_reflex = new Float32Array(this.W_reflex);
        clone.W_M_work = copyMat(this.W_M_work); clone.b_M_work = new Float32Array(this.b_M_work);
        clone.W_M_perm = copyMat(this.W_M_perm); clone.b_M_perm = new Float32Array(this.b_M_perm);
        clone.W_M_pred = copyMat(this.W_M_pred); clone.b_M_pred = new Float32Array(this.b_M_pred);
        clone.W_C = copyMat(this.W_C); clone.b_C = new Float32Array(this.b_C);
        clone.W_S = copyMat(this.W_S); clone.b_S = new Float32Array(this.b_S);
        clone.W_D = copyMat(this.W_D); clone.b_D = new Float32Array(this.b_D);
        clone.W_pred = copyMat(this.W_pred); clone.b_pred = new Float32Array(this.b_pred);
        clone.W_V = new Float32Array(this.W_V); clone.b_V = this.b_V;
        clone.W_key = new Float32Array(this.W_key);
        clone.P.set(this.P); clone.A.set(this.A); clone.M.set(this.M);
        clone.C.set(this.C); clone.S.set(this.S); clone.D.set(this.D);
        clone.P_prev.set(this.P_prev); clone.A_prev.set(this.A_prev); clone.M_prev.set(this.M_prev);
        clone.C_prev.set(this.C_prev); clone.S_prev.set(this.S_prev); clone.D_prev.set(this.D_prev);
        clone.predictionErrors.set(this.predictionErrors);
        clone.trace_P.set(this.trace_P); clone.trace_C.set(this.trace_C);
        clone.trace_D.set(this.trace_D); clone.trace_pred.set(this.trace_pred);
        clone._stats = { ...this._stats, tdErrorHistory: [...this._stats.tdErrorHistory] };
        clone.consolidationBuffer = [...this.consolidationBuffer.map(x => ({...x}))];
        clone.emotions = { ...this.emotions };
        clone.emotionHistory = [...this.emotionHistory];
        clone.emotionalState = Utils.deepClone(this.emotionalState);
        clone.emotionMemory = {
            trauma: this.emotionMemory.trauma,
            grudge: new Map(this.emotionMemory.grudge),
            lastEmotion: this.emotionMemory.lastEmotion ? { ...this.emotionMemory.lastEmotion } : null,
            unresolved: this.emotionMemory.unresolved, killer: this.emotionMemory.killer
        };
        clone.emotionConfig = Utils.deepClone(this.emotionConfig);
        clone.emotionDecay = this.emotionDecay;
        clone.emotionInfluence = this.emotionInfluence;
        clone.step = this.step;
        clone.cumulativeReward = this.cumulativeReward;
        clone.health = this.health;
        clone.stats = { ...this.stats };
        clone._lastKiller = this._lastKiller;
        clone.predictedPos60 = { ...this.predictedPos60 };        clone.predictionError60 = this.predictionError60;
        clone.predictedTrajectory = { ...this.predictedTrajectory };
        return clone;
    }
    toJSON() {
        return {
            type: 'Cortex2Brain', version: '2.0',
            config: {
                seed: this.seed, lr: this.lr, gamma: this.gamma, lambda: this.lambda,
                dims: { P: this.DIM.DIM_P, A: this.DIM.DIM_A, M: this.DIM.DIM_M, C: this.DIM.DIM_C, S: this.DIM.DIM_S, D: this.DIM.DIM_D }
            },
            weights: {
                W_P: this.W_P.map(r => Array.from(r)), b_P: Array.from(this.b_P),
                W_A: this.W_A.map(m => m.map(r => Array.from(r))), b_A: this.b_A.map(b => Array.from(b)),
                W_gate: Array.from(this.W_gate), W_reflex: Array.from(this.W_reflex),
                W_M_work: this.W_M_work.map(r => Array.from(r)), b_M_work: Array.from(this.b_M_work),
                W_M_perm: this.W_M_perm.map(r => Array.from(r)), b_M_perm: Array.from(this.b_M_perm),
                W_M_pred: this.W_M_pred.map(r => Array.from(r)), b_M_pred: Array.from(this.b_M_pred),
                W_C: this.W_C.map(r => Array.from(r)), b_C: Array.from(this.b_C),
                W_S: this.W_S.map(r => Array.from(r)), b_S: Array.from(this.b_S),
                W_D: this.W_D.map(r => Array.from(r)), b_D: Array.from(this.b_D),
                W_pred: this.W_pred.map(r => Array.from(r)), b_pred: Array.from(this.b_pred),
                W_V: Array.from(this.W_V), b_V: this.b_V,
                W_key: Array.from(this.W_key)
            },
            state: {
                P: Array.from(this.P), A: Array.from(this.A), M: Array.from(this.M),
                C: Array.from(this.C), S: Array.from(this.S), D: Array.from(this.D),
                P_prev: Array.from(this.P_prev), A_prev: Array.from(this.A_prev), M_prev: Array.from(this.M_prev),
                C_prev: Array.from(this.C_prev), S_prev: Array.from(this.S_prev), D_prev: Array.from(this.D_prev),
                predictionErrors: Array.from(this.predictionErrors)
            },
            stats: this._stats, emotions: { ...this.emotions },
            emotionalState: Utils.deepClone(this.emotionalState),
            emotionMemory: {
                trauma: this.emotionMemory.trauma,
                grudge: Array.from(this.emotionMemory.grudge.entries()),
                lastEmotion: this.emotionMemory.lastEmotion,
                unresolved: this.emotionMemory.unresolved, killer: this.emotionMemory.killer
            },
            emotionConfig: Utils.deepClone(this.emotionConfig),
            emotionDecay: this.emotionDecay, emotionInfluence: this.emotionInfluence,
            step: this.step, cumulativeReward: this.cumulativeReward,
            health: this.health, stats_copy: { ...this.stats }, _lastKiller: this._lastKiller,
            predictedPos60: this.predictedPos60,
            predictionError60: this.predictionError60,
            predictedTrajectory: this.predictedTrajectory
        };
    }
    static fromJSON(data) {
        if (!data || data.type !== 'Cortex2Brain' || !data.config) return new Cortex2Brain({});
        const brain = new Cortex2Brain(data.config);
        try {
            const w = data.weights;
            brain.W_P = w.W_P.map(r => new Float32Array(r)); brain.b_P = new Float32Array(w.b_P);
            brain.W_A = w.W_A.map(m => m.map(r => new Float32Array(r))); brain.b_A = w.b_A.map(b => new Float32Array(b));
            if (w.W_gate) brain.W_gate = new Float32Array(w.W_gate);
            if (w.W_reflex) brain.W_reflex = new Float32Array(w.W_reflex);
            brain.W_M_work = w.W_M_work.map(r => new Float32Array(r)); brain.b_M_work = new Float32Array(w.b_M_work);
            brain.W_M_perm = w.W_M_perm.map(r => new Float32Array(r)); brain.b_M_perm = new Float32Array(w.b_M_perm);
            brain.W_M_pred = w.W_M_pred.map(r => new Float32Array(r)); brain.b_M_pred = new Float32Array(w.b_M_pred);
            brain.W_C = w.W_C.map(r => new Float32Array(r)); brain.b_C = new Float32Array(w.b_C);
            brain.W_S = w.W_S.map(r => new Float32Array(r)); brain.b_S = new Float32Array(w.b_S);
            brain.W_D = w.W_D.map(r => new Float32Array(r)); brain.b_D = new Float32Array(w.b_D);
            brain.W_pred = w.W_pred.map(r => new Float32Array(r)); brain.b_pred = new Float32Array(w.b_pred);
            if (w.W_V) { brain.W_V = new Float32Array(w.W_V); brain.b_V = w.b_V ?? 0; }
            if (w.W_key) brain.W_key = new Float32Array(w.W_key);
            const s = data.state;
            brain.P.set(s.P); brain.A.set(s.A); brain.M.set(s.M);
            brain.C.set(s.C); brain.S.set(s.S); brain.D.set(s.D);
            brain.P_prev.set(s.P_prev); brain.A_prev.set(s.A_prev); brain.M_prev.set(s.M_prev);
            brain.C_prev.set(s.C_prev); brain.S_prev.set(s.S_prev); brain.D_prev.set(s.D_prev);
            brain.predictionErrors.set(s.predictionErrors);
            if (data.stats) brain._stats = { ...data.stats };
            if (data.emotions) brain.emotions = { ...data.emotions };
            if (data.emotionalState) brain.emotionalState = Utils.deepClone(data.emotionalState);
            if (data.emotionMemory) {
                brain.emotionMemory.trauma = data.emotionMemory.trauma || 0;
                brain.emotionMemory.grudge = new Map(data.emotionMemory.grudge || []);
                brain.emotionMemory.lastEmotion = data.emotionMemory.lastEmotion;
                brain.emotionMemory.unresolved = data.emotionMemory.unresolved || 0;
                brain.emotionMemory.killer = data.emotionMemory.killer;
            }
            if (data.emotionConfig) brain.emotionConfig = Utils.deepClone(data.emotionConfig);
            if (data.emotionDecay) brain.emotionDecay = data.emotionDecay;
            if (data.emotionInfluence !== undefined) brain.emotionInfluence = data.emotionInfluence;
            if (data.step) brain.step = data.step;
            if (data.cumulativeReward !== undefined) brain.cumulativeReward = data.cumulativeReward;
            if (data.health) brain.health = data.health;
            if (data.stats_copy) brain.stats = { ...data.stats_copy };
            if (data._lastKiller) brain._lastKiller = data._lastKiller;
            if (data.predictedPos60) brain.predictedPos60 = data.predictedPos60;
            if (data.predictionError60 !== undefined) brain.predictionError60 = data.predictionError60;
            if (data.predictedTrajectory) brain.predictedTrajectory = data.predictedTrajectory;
        } catch(e) { console.warn('Cortex2Brain.fromJSON error:', e); }
        return brain;
    }

    getActiveNeurons() { return [...this._activeNeurons]; }    getAttentionWeights() { return this._attentionHeadNorms ? [...this._attentionHeadNorms] : null; }
    getStats() { return { ...this._stats }; }
    getEmotions() { return { ...this.emotions }; }
    interpret() {
        const threat = this.S[0] > 0.5 ? 'HIGH' : this.S[0] > 0.2 ? 'MED' : 'LOW';
        const flank = this.A[16] > 0.4 ? 'SEEKING' : this.A[16] > 0.15 ? 'NEUTRAL' : 'IGNORE';
        const memoryConf = 1 - this._computeAvgPredError();
        const reflexActive = this.S.some(v => v > 0.8);
        const cortexEnergy = this.C.reduce((s,v) => s + Math.abs(v), 0) / this.DIM.DIM_C;
        return {
            threat, flank, memoryConf: memoryConf.toFixed(2), reflexActive,
            cortexEnergy: cortexEnergy.toFixed(3),
            emotions: { ...this.emotions },
            emotionalState: this.emotionalState.current ? { ...this.emotionalState.current } : null,
            prediction: {
                pos60: this.predictedPos60,
                error60: this.predictionError60.toFixed(2),
                trajectory: this.predictedTrajectory
            }
        };
    }

    updateDiagnostics(metrics) {
        if (!metrics) return;
        if (metrics.win !== undefined) this._stats.kills += metrics.win ? 1 : 0;
        if (metrics.reward !== undefined) this._stats.avgReward = Utils.lerp(this._stats.avgReward, Utils.safeNumber(metrics.reward, 0), 0.01);
    }
}

// ============================================================================
// SECTION 5-7: Critic, Policy, Projectile
// ============================================================================

class CriticNetwork {
    constructor(config = {}) {
        this.inputDim = config.inputDim ?? (arenaConfig.compactInputs ? arenaConfig.ARCH.INPUT_DIM_COMPACT : arenaConfig.ARCH.INPUT_DIM);
        this.hidden = config.hidden ?? arenaConfig.ARCH.CRITIC_HIDDEN;
        this.seed = config.seed ?? (arenaConfig.seed + '_CRITIC');
        this._rng = new SeededRNG(this.seed);
        this._W1 = this._rng.deriveWeights(this.inputDim, this.hidden, 0.3);
        this._W2 = this._rng.deriveWeights(this.hidden, 1, 0.1);
        this._b1 = this._rng.deriveVector(this.hidden, 0.1);
        this._b2 = 0;
        this.lr = config.lr ?? arenaConfig.learningRate;
        this.gamma = config.gamma ?? arenaConfig.gamma;
    }
    forward(inputs) {
        if (!Array.isArray(inputs) || inputs.length !== this.inputDim) {
            inputs = new Array(this.inputDim).fill(0);
        }        const hidden = [];
        for (let o = 0; o < this.hidden; o++) {
            let sum = Utils.safeNumber(this._b1[o], 0);
            for (let i = 0; i < inputs.length; i++) {
                sum += Utils.safeNumber(inputs[i], 0) * Utils.safeNumber(this._W1[i]?.[o], 0);
            }
            hidden.push(Utils.leakyRelu(sum));
        }
        let value = this._b2;
        for (let i = 0; i < this.hidden; i++) {
            value += Utils.safeNumber(hidden[i], 0) * Utils.safeNumber(this._W2[i]?.[0], 0);
        }
        return Utils.clamp(value, -10, 10);
    }
    update(inputs, reward, nextValue, alpha = null) {
        const currentValue = this.forward(inputs);
        const tdErr = Utils.tdError(reward, currentValue, nextValue, this.gamma);
        const lr = alpha ?? this.lr;
        this._b2 += lr * tdErr;
        return { tdError: tdErr, value: currentValue };
    }
    clone() {
        const clone = new CriticNetwork({
            inputDim: this.inputDim, hidden: this.hidden,
            seed: this.seed + '_clone', lr: this.lr, gamma: this.gamma
        });
        clone._W1 = this._W1.map(r => r.slice());
        clone._W2 = this._W2.map(r => r.slice());
        clone._b1 = this._b1.slice();
        clone._b2 = this._b2;
        return clone;
    }
    toJSON() {
        return {
            config: { inputDim: this.inputDim, hidden: this.hidden, seed: this.seed, lr: this.lr, gamma: this.gamma },
            W1: this._W1.map(r => r.slice()), W2: this._W2.map(r => r.slice()),
            b1: this._b1.slice(), b2: this._b2
        };
    }
    static fromJSON(data) {
        if (!data?.config) return new CriticNetwork({});
        const c = new CriticNetwork(data.config);
        c._W1 = (data.W1 || []).map(r => (r || []).slice());
        c._W2 = (data.W2 || []).map(r => (r || []).slice());
        c._b1 = (data.b1 || []).slice();
        c._b2 = data.b2 ?? 0;
        return c;
    }
}
class PolicySelector {
    constructor(config = {}) {
        this.contextDim = config.contextDim ?? arenaConfig.ARCH.POLICY_CONTEXT_DIM;
        this.skillEmbeddingDim = config.skillEmbeddingDim ?? arenaConfig.ARCH.POLICY_SKILL_DIM;
        this.hidden = config.hidden ?? arenaConfig.ARCH.POLICY_HIDDEN;
        this.numModes = config.numModes ?? arenaConfig.ARCH.POLICY_MODES;
        this.seed = config.seed ?? (arenaConfig.seed + '_POLICY');
        this._rng = new SeededRNG(this.seed);
        this._W1 = this._rng.deriveWeights(this.contextDim + this.skillEmbeddingDim, this.hidden, 0.2);
        this._W2 = this._rng.deriveWeights(this.hidden, this.numModes, 0.15);
        this._b1 = this._rng.deriveVector(this.hidden, 0.1);
        this.lr = config.lr ?? arenaConfig.learningRate * 0.6;
    }
    forward(context, skillEmbedding) {
        const combined = [...(context || []), ...(skillEmbedding || [])];
        const hidden = [];
        for (let o = 0; o < this.hidden; o++) {
            let sum = Utils.safeNumber(this._b1[o], 0);
            for (let i = 0; i < combined.length; i++) {
                sum += Utils.safeNumber(combined[i], 0) * Utils.safeNumber(this._W1[i]?.[o], 0);
            }
            hidden.push(Utils.leakyRelu(sum));
        }
        const logits = [];
        for (let m = 0; m < this.numModes; m++) {
            let sum = 0;
            for (let i = 0; i < this.hidden; i++) {
                sum += Utils.safeNumber(hidden[i], 0) * Utils.safeNumber(this._W2[i]?.[m], 0);
            }
            logits.push(sum);
        }
        return { probs: Utils.softmax(logits, 0.8), hidden };
    }
    update(context, skillEmbedding, selectedMode, advantage) {
        const { probs, hidden } = this.forward(context, skillEmbedding);
        const lr = this.lr * Math.sign(advantage);
        for (let i = 0; i < this.hidden; i++) {
            for (let m = 0; m < this.numModes; m++) {
                const targetGrad = (m === selectedMode ? 1 : 0) - Utils.safeNumber(probs[m], 0);
                this._W2[i][m] += lr * advantage * targetGrad * Utils.safeNumber(hidden[i], 0);
                this._W2[i][m] = Utils.clamp(this._W2[i][m], -2, 2);
            }
        }
    }
    clone() {
        const clone = new PolicySelector({
            contextDim: this.contextDim, skillEmbeddingDim: this.skillEmbeddingDim,
            hidden: this.hidden, numModes: this.numModes,
            seed: this.seed + '_clone', lr: this.lr
        });        clone._W1 = this._W1.map(r => r.slice());
        clone._W2 = this._W2.map(r => r.slice());
        clone._b1 = this._b1.slice();
        return clone;
    }
    toJSON() {
        return {
            config: { contextDim: this.contextDim, skillEmbeddingDim: this.skillEmbeddingDim, hidden: this.hidden, numModes: this.numModes, seed: this.seed, lr: this.lr },
            W1: this._W1.map(r => r.slice()), W2: this._W2.map(r => r.slice()), b1: this._b1.slice()
        };
    }
    static fromJSON(data) {
        if (!data?.config) return new PolicySelector({});
        const ps = new PolicySelector(data.config);
        ps._W1 = (data.W1 || []).map(r => (r || []).slice());
        ps._W2 = (data.W2 || []).map(r => (r || []).slice());
        ps._b1 = (data.b1 || []).slice();
        return ps;
    }
}

class Projectile {
    constructor(x, y, vx, vy, owner, damage = 3, life = 80) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.owner = owner; this.damage = damage; this.life = life;
        this.alive = true; this.radius = 3;
    }
    update(dt) {
        this.x += this.vx * dt * 8;
        this.y += this.vy * dt * 8;
        this.life -= dt;
        if (this.life <= 0) this.alive = false;
    }
    draw(ctx) {
        if (!this.alive) return;
        ctx.fillStyle = '#ffdd44';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ============================================================================
// PATCH B.1: HealthPack class
// ============================================================================
class HealthPack {
    constructor(x, y, healAmount = 25, lifetime = 30 * 60) {
        this.x = x; this.y = y;
        this.healAmount = healAmount;
        this.lifetime = lifetime;        this.radius = 12;
        this.collected = false;
        this.pulsePhase = 0;
        this.color = '#00ff9d';
    }
    
    update(dt) {
        this.lifetime -= dt;
        this.pulsePhase += dt * 0.15;
        if (this.lifetime <= 0) this.collected = true;
    }
    
    draw(ctx) {
        if (this.collected) return;
        const pulse = 1 + Math.sin(this.pulsePhase) * 0.15;
        const r = this.radius * pulse;
        
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, r * 2);
        gradient.addColorStop(0, 'rgba(0, 255, 157, 0.4)');
        gradient.addColorStop(0.5, 'rgba(0, 255, 157, 0.1)');
        gradient.addColorStop(1, 'rgba(0, 255, 157, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, r * 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#0a0a15';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x - r * 0.6, this.y);
        ctx.lineTo(this.x + r * 0.6, this.y);
        ctx.moveTo(this.x, this.y - r * 0.6);
        ctx.lineTo(this.x, this.y + r * 0.6);
        ctx.stroke();
    }
    
    isCollectedBy(agent) {
        if (this.collected) return false;
        return Utils.dist(this, agent) < (this.radius + (agent.COLLISION_RADIUS || 22));
    }
    
    toJSON() {
        return { x: this.x, y: this.y, healAmount: this.healAmount, 
                 lifetime: this.lifetime, collected: this.collected, pulsePhase: this.pulsePhase };
    }    
    static fromJSON(data) {
        const pack = new HealthPack(data.x, data.y, data.healAmount, data.lifetime);
        pack.collected = data.collected;
        pack.pulsePhase = data.pulsePhase || 0;
        return pack;
    }
}

// ============================================================================
// SECTION 8: AGENT CLASS (10/10 AUDITED)
// ============================================================================

class Agent {
    static get VISUAL_RADIUS() { return 22; }
    static get COLLISION_RADIUS() { return 22; }
    static get ATTACK_RANGE() { return 45; }

    constructor(id, x, y, color, seed, weaponType = 'hammer', team = 'blue') {
        this.id = id; this.x = x; this.y = y; this.color = color;
        this.seed = seed;
        this.team = (team === 'red') ? 'red' : 'blue';
        this.vx = 0; this.vy = 0; this.velocity = { x: 0, y: 0 };
        this.facingAngle = 0;
        this.stats = { maxHealth: 100, damage: 3, fireRate: 15, dodgeChance: 0.0 };
        this.health = this.stats.maxHealth;
        this.lastMutationType = null;
        this.weaponType = weaponType;
        this.weapon = WEAPONS[weaponType] || WEAPONS.hammer;
        this._applyWeaponStats();
        this.bodyVertices = [
            { x: 20, y: -14 }, { x: 20, y: 14 },
            { x: -18, y: 14 }, { x: -18, y: -14 }
        ];
        this.net = new Cortex2Brain({
            seed: seed + '_CORTEX2_' + id,
            lr: arenaConfig.learningRate,
            gamma: arenaConfig.gamma,
            lambda: arenaConfig.lambda,
            hebbianRate: arenaConfig.hebbianRate
        });
        this.critic = new CriticNetwork({
            inputDim: arenaConfig.compactInputs ? arenaConfig.ARCH.INPUT_DIM_COMPACT : arenaConfig.ARCH.INPUT_DIM,
            hidden: arenaConfig.ARCH.CRITIC_HIDDEN,
            seed: seed + '_CRITIC_' + id,
            lr: arenaConfig.learningRate,
            gamma: arenaConfig.gamma
        });
        this.policySelector = new PolicySelector({
            contextDim: arenaConfig.ARCH.POLICY_CONTEXT_DIM,            skillEmbeddingDim: arenaConfig.ARCH.POLICY_SKILL_DIM,
            hidden: arenaConfig.ARCH.POLICY_HIDDEN,
            numModes: arenaConfig.ARCH.POLICY_MODES,
            seed: seed + '_POLICY_' + id,
            lr: arenaConfig.learningRate * 0.6
        });
        this.mode = 'combat'; this.target = { x, y }; this.speed = 1;
        this.stuckCounter = 0; this.lastPos = { x, y };
        this.cumulativeReward = 0; this.alive = true;
        this.skillEmbedding = [0.3, 0.4, 0.2, 0.5, 0.6];
        this.socialMemory = {
            interactions: new Map(), reputation: 0, allies: [], enemies: [],
            killerHistory: [], allianceHistory: [], favors: new Map(), groupAffiliation: null
        };
        this.permanent = {
            skills: { hunting: 0.3, fleeing: 0.4, combat: 0.2, exploring: 0.5, avoiding: 0.6 },
            strategies: { huntPattern: 'direct', fleeDirection: 'away', combatStyle: 'direct' },
            preferences: { foodType: 'any', enemyType: 'any', territory: 'any' },
            muscleMemory: new Float32Array(16).fill(0),
            memory: { lastFoodPos: null, lastFoodStep: 0, visited: new Set(), unvisited: [] }
        };
        this.predictive = {
            shortTerm: { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] },
            patterns: { enemyMovement: null, foodSpawn: null, dangerZones: new Map() },
            predictions: { enemyPos: { x: 0, y: 0 }, foodPos: { x: 0, y: 0 }, collision: false, success: 0.5 },
            confidence: 0.5, predictionError: 0
        };
        this.enemyPredictor = new (class {
            constructor() { this.history = []; this.maxHistory = 50; }
            recordMove(action, distance, health, aggression) {
                this.history.push({ action: { ...action }, distance, health, aggression, time: Date.now() });
                if (this.history.length > this.maxHistory) this.history.shift();
            }
            predictNextAction() {
                if (this.history.length < 5) return 'unpredictable';
                const recent = this.history.slice(-5);
                const avgAgg = recent.reduce((s, m) => s + Utils.safeNumber(m.action?.aggression, 0.5), 0) / recent.length;
                if (Math.abs(avgAgg) > 0.7) return avgAgg > 0 ? 'aggressive' : 'fleeing';
                return 'unpredictable';
            }
            predictPosition(secondsAhead) {
                if (this.history.length < 3) {
                    const last = this.history[this.history.length - 1];
                    return { x: last.x, y: last.y };
                }
                const last = this.history[this.history.length - 1];
                const prev = this.history[this.history.length - 2];
                const dt = (last.step - prev.step) / 60;
                const predVx = (last.x - prev.x) / dt;
                const predVy = (last.y - prev.y) / dt;                return {
                    x: last.x + predVx * secondsAhead,
                    y: last.y + predVy * secondsAhead
                };
            }
        })();
        this.strategyMemory = new (class {
            constructor() { this.winningStrategies = []; this.fightHistory = {}; this.maxStrategies = 20; }
            recordFight(opponentId, won, weights, tactics, accuracy) {
                if (!this.fightHistory[opponentId]) this.fightHistory[opponentId] = { wins: 0, losses: 0, lastTactics: null, bestAccuracy: 0 };
                const hist = this.fightHistory[opponentId];
                if (won) { hist.wins++; hist.lastTactics = tactics; hist.bestAccuracy = Math.max(hist.bestAccuracy, accuracy || 0); }
                else { hist.losses++; }
            }
        })();
        this.currentTactic = 'assault';
        this.fightStartTime = 0; this.fightOpponent = null;
        this.attackCooldown = 0; this.attackRange = this.weapon.range;
        this.wins = 0; this.totalKills = 0; this.deaths = 0; this.mutations = 0;
        this.generation = 1; this.trail = []; this.lastDecision = null;
        this._lastWorld = null;
        this.learningBuffer = { states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [], maxBuffer: 32 };
        this.evolutionPoints = 0;
        this.statChoices = ['maxHealth', 'damage', 'dodgeChance', 'fireRate'];
        this._lastHitDealt = 0; this._lastHitReceived = 0;
        this._knockbackVelocity = { x: 0, y: 0 }; this._stunTimer = 0;
        this._weaponEffectTimer = 0; this._forcedCombatTimer = 0;
        this._learnFromWinner = false; this._lastKiller = null; this._deathMode = null;
        this._totalDamageDealt = 0; this._totalAttacks = 0; this._successfulHits = 0;
        this._tacticalHits = 0; this._frontalHits = 0; this._lastAttackDir = null;
        this._recentArcExposure = []; this._inEnemyArc = false;
        this._lastThreatAssessment = null; this._angleToEnemy = 0;
        this._wallDistance = 999; this._isFacingEnemy = false;
        this._attackValid = false; this._exposure = { level: 0, type: 'none' };
        this._inCombatRange = false; this._combatEvents = [];
        this.decisionCommitment = {
            current: null,
            minFrames: { attack: 45, retreat: 30, flank: 60, approach: 30 }
        };
        this.actionState = {
            phase: 'idle', startTime: 0, expectedDuration: 0,
            targetPosition: null, completed: false
        };
        this.world = null;
        this.moveVector = { x: 0, y: 0 };
        this.moveSpeed = 1;
        this.mentalMap = {
            enemies: new Map(),
            lastUpdate: 0,
            targetPriority: null        };
        this.assignedTargetId = null;
        this.assignedRole = 'assault';
        this.explorationTarget = null;
        this._combatTimer = 0;
        this.predictedIntercept = null;
        this._moveAngle = null;
        
        this._inputBuffer = new Float32Array(64);
        this._enemyCache = [];
        this._allyCache = [];
        
        this._wasAttackingLastFrame = false;
        this._attackToggleTimer = 0;
        
        this._targetDeathFrame = null;
        this._targetSwitchFrame = null;
    }

    _applyWeaponStats() {
        const w = this.weapon;
        this.stats.damage = Math.floor(3 * w.damage);
        this.stats.fireRate = Math.floor(15 / w.speed);
        this.attackRange = w.range;
    }

    setWeapon(weaponType) {
        if (WEAPONS[weaponType]) {
            this.weaponType = weaponType;
            this.weapon = WEAPONS[weaponType];
            this._applyWeaponStats();
            return true;
        }
        return false;
    }

    getWeaponFacing() { return this.facingAngle; }

    isPointInWeaponArc(point, extraArc = 0) {
        if (!point || typeof point.x !== 'number' || !isFinite(point.x)) return false;
        const facing = this.facingAngle;
        const toPoint = Math.atan2(point.y - this.y, point.x - this.x);
        let angleDiff = Utils.normalizeAngle(toPoint - facing);
        const effectiveArc = (this.weapon.arcAngle || Math.PI) + extraArc;
        const inArc = Math.abs(angleDiff) <= effectiveArc / 2;
        
        if (inArc && this.world?.walls?.length) {
            const hasLOS = Utils.hasLineOfSight(this, point, this.world.walls, 6);
            return hasLOS;
        }        
        return inArc;
    }

    calculateDirectionalDamageMultiplier(attacker) {
        if (!attacker) return 1.0;
        const toAttacker = Math.atan2(attacker.y - this.y, attacker.x - this.x);
        let angleDiff = Utils.normalizeAngle(toAttacker - this.facingAngle);
        const absAngle = Math.abs(angleDiff);
        const weaponArc = (this.weapon.arcAngle || Math.PI) / 2;
        if (absAngle <= weaponArc * 0.5) return arenaConfig.TACTICAL.DAMAGE_FRONT;
        else if (absAngle <= weaponArc) return arenaConfig.TACTICAL.DAMAGE_FLANK;
        else return arenaConfig.TACTICAL.DAMAGE_BACK;
    }

    assessThreatFromEnemy(enemy) {
        if (!enemy?.alive) return { threatLevel: 0, safeApproachAngle: 0, flankVector: {x:0, y:0} };
        const dist = Utils.dist(this, enemy);
        const inRange = dist <= (enemy.weapon.range || 50);
        const toMe = Math.atan2(this.y - enemy.y, this.x - enemy.x);
        const enemyToMeAngle = Utils.normalizeAngle(toMe - enemy.facingAngle);
        const inEnemyArc = Math.abs(enemyToMeAngle) <= (enemy.weapon.arcAngle || Math.PI) / 2;
        let threatLevel = inRange ? (inEnemyArc ? 0.95 : 0.4) : (inEnemyArc ? 0.5 : 0.1);
        threatLevel *= Utils.lerp(0.7, 1.0, enemy.health / enemy.stats.maxHealth);
        const safeAngle = enemy.facingAngle + Math.PI + Utils.rand(-0.3, 0.3);
        const perpDir = { x: -Math.sin(enemy.facingAngle), y: Math.cos(enemy.facingAngle) };
        const flankSign = Math.random() < 0.5 ? 1 : -1;
        const flankVector = Utils.normalize(perpDir.x * flankSign, perpDir.y * flankSign);
        this._lastThreatAssessment = { threatLevel, safeAngle, flankVector };
        return { threatLevel: Utils.clamp(threatLevel, 0, 1), safeApproachAngle: safeAngle, flankVector: flankVector };
    }

    interpretAttention() {
        const cortexInterp = this.net.interpret?.() || {};
        return { threat: cortexInterp.threat || '‚Äî', flank: cortexInterp.flank || '‚Äî', distance: '‚Äî', prediction: cortexInterp.memoryConf || '‚Äî', emotions: cortexInterp.emotions };
    }

    predictEnemyIntent(enemy, worldHistory) {
        if (!enemy?.alive) return { intent: 'none', confidence: 1.0 };
        const dist = Utils.dist(this, enemy);
        const prevDist = worldHistory?.lastDist ?? dist;
        const approachSpeed = (prevDist - dist) / (worldHistory?.dt ?? 1);
        const enemyVel = Math.hypot(enemy.vx ?? 0, enemy.vy ?? 0);
        const inArc = enemy.isPointInWeaponArc(this);
        const inRange = dist <= (enemy.weapon.range || 50);
        const enemyHealthRatio = enemy.health / enemy.stats.maxHealth;
        if (enemyHealthRatio < 0.3 && inRange && approachSpeed > 3) return { intent: 'desperate_attack', confidence: 0.85 };
        if (inArc && inRange && (approachSpeed > 2 || enemyVel > 8)) return { intent: 'attack', confidence: 0.75 };
        if (enemyHealthRatio < 0.4 && approachSpeed < -2) return { intent: 'flee', confidence: 0.8 };
        if (dist < 80 && approachSpeed > 4 && !inArc) return { intent: 'flank', confidence: 0.65 };        return { intent: 'unknown', confidence: 0.5 };
    }
    getInputs(world) {
        this._enemyCache.length = 0;
        this._allyCache.length = 0;
        
        const viewRadius = arenaConfig.viewRadius || 250;
        const now = world?.step || 0;
        
        const visibleEnemies = [];
        for (const entity of world?.enemies || []) {
            if (!entity?.alive || entity.id === this.id || entity.team === this.team) continue;
            const dx = entity.x - this.x;
            const dy = entity.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist <= viewRadius) {
                this._enemyCache.push({
                    id: entity.id,
                    dx: dx / viewRadius,
                    dy: dy / viewRadius,
                    dist: dist / viewRadius,
                    hp: entity.health / entity.stats.maxHealth,
                    vx: entity.vx / 15,
                    vy: entity.vy / 15,
                    threat: Utils.threatScore(this, entity)
                });
            }
        }
        this._enemyCache.sort((a, b) => b.threat - a.threat);
        for (let i = 0; i < Math.min(5, this._enemyCache.length); i++) {
            const e = this._enemyCache[i];
            this._inputBuffer[i*4] = e.dx;
            this._inputBuffer[i*4+1] = e.dy;
            this._inputBuffer[i*4+2] = e.dist;
            this._inputBuffer[i*4+3] = e.threat;
        }
        
        const allies = (world?.enemies || [])
            .filter(e => e?.alive && e.team === this.team && e.id !== this.id)
            .map(a => ({
                dx: (a.x - this.x) / viewRadius,
                dy: (a.y - this.y) / viewRadius,
                dist: Utils.dist(this, a) / viewRadius,
                hp: a.health / a.stats.maxHealth
            }))
            .sort((a, b) => a.dist - b.dist)
            .slice(0, 3);
        
        for (let i = 0; i < 3; i++) {
            const offset = 20 + i * 3;            if (i < allies.length) {
                this._inputBuffer[offset] = allies[i].dx;
                this._inputBuffer[offset+1] = allies[i].dy;
                this._inputBuffer[offset+2] = allies[i].dist;
            } else {
                this._inputBuffer[offset] = 0; this._inputBuffer[offset+1] = 0; this._inputBuffer[offset+2] = 1;
            }
        }
        this._inputBuffer[29] = allies.length > 0 ? 1 : 0;
        
        if (this._enemyCache.length > 0) {
            this._inputBuffer[30] = this._enemyCache[0].vx;
            this._inputBuffer[31] = this._enemyCache[0].vy;
        }
        
        const targetDistribution = new Map();
        allies.forEach(a => {
            if (a.targetId) {
                targetDistribution.set(a.targetId, (targetDistribution.get(a.targetId) || 0) + 1);
            }
        });
        
        this._inputBuffer[32] = allies.filter(a => a.role === 'assault').length / 4;
        this._inputBuffer[33] = allies.filter(a => a.role === 'support').length / 4;
        this._inputBuffer[34] = allies.filter(a => a.role === 'flank').length / 4;
        this._inputBuffer[35] = targetDistribution.size > 0 ? 1 : 0;
        this._inputBuffer[36] = targetDistribution.size > 1 ? 1 : 0;
        this._inputBuffer[37] = allies.length > 0 ? allies.reduce((s,a) => s + (a.hp < 0.3 ? 1 : 0), 0) / allies.length : 0;
        this._inputBuffer[38] = allies.length > 0 ? allies.reduce((s,a) => s + a.hp, 0) / allies.length : 0.5;
        
        this._inputBuffer[39] = this.health / this.stats.maxHealth;
        this._inputBuffer[40] = this.vx / 15;
        this._inputBuffer[41] = this.vy / 15;
        this._inputBuffer[42] = this.facingAngle / Math.PI;
        this._inputBuffer[43] = Utils.clamp(this.cumulativeReward / 50, -1, 1);
        this._inputBuffer[44] = this.attackCooldown / this.stats.fireRate;
        this._inputBuffer[45] = this.stuckCounter / 30;
        
        const weaponTypes = Object.keys(WEAPONS);
        for (let i = 0; i < 8; i++) {
            this._inputBuffer[46+i] = this.weaponType === weaponTypes[i] ? 1 : 0;
        }
        
        const teamAlive = (world?.enemies || []).filter(a => a?.alive && a.team === this.team).length;
        const enemyAlive = (world?.enemies || []).filter(a => a?.alive && a.team !== this.team).length;
        this._inputBuffer[54] = teamAlive / 4;
        this._inputBuffer[55] = enemyAlive / 4;
        this._inputBuffer[56] = (teamAlive - enemyAlive) / 4;
        this._inputBuffer[57] = this._calculateTargetConsensus(world);
        this._inputBuffer[58] = this.cumulativeReward / 100;        this._inputBuffer[59] = this._getLastTeamReward(world);
        this._inputBuffer[60] = this._getTacticalUrgency(world);
        
        const alliesUnderFire = allies.filter(a => a._lastHitReceived > 0 && a._lastHitReceived < 5).length;
        this._inputBuffer[61] = alliesUnderFire / Math.max(1, allies.length);
        
        this._inputBuffer[62] = Utils.hashSeed(this.seed, this.id, 0);
        this._inputBuffer[63] = Utils.hashSeed(this.seed, this.id, 1);
        
        for (let i = 0; i < 64; i++) {
            if (!isFinite(this._inputBuffer[i])) {
                this._inputBuffer[i] = 0;
            }
        }
        
        return Array.from(this._inputBuffer);
    }

    _calculateTargetConsensus(world) {
        const team = this.team;
        const targetCounts = new Map();
        for (const agent of world?.enemies || []) {
            if (agent?.alive && agent.team === team && agent.mentalMap?.targetPriority) {
                const targetId = agent.mentalMap.targetPriority.id;
                targetCounts.set(targetId, (targetCounts.get(targetId) || 0) + 1);
            }
        }
        if (targetCounts.size === 0) return 0;
        const maxFocus = Math.max(...targetCounts.values());
        return maxFocus / Math.max(1, (world?.enemies?.filter(a => a?.team === team && a?.alive).length || 1));
    }

    _getLastTeamReward(world) {
        const teamWins = (world?.enemies || []).filter(a => a?.team === this.team && a.wins > 0).length;
        return teamWins > 0 ? 0.5 : 0;
    }

    _getTacticalUrgency(world) {
        const hpRatio = this.health / this.stats.maxHealth;
        const nearbyEnemies = (world?.enemies || []).filter(e => 
            e?.alive && e.team !== this.team && Utils.dist(this, e) < 100
        ).length;
        return Utils.clamp((1 - hpRatio) * 0.5 + nearbyEnemies * 0.2, 0, 1);
    }

    _selectPriorityTarget(world) {
        let bestTarget = null;
        let bestScore = -Infinity;
        this.mentalMap.enemies.forEach((enemy, id) => {
            if (enemy.confidence < 0.3) return;            const score = (enemy.threat * enemy.hp * enemy.confidence) / (enemy.dist + 0.1);
            if (score > bestScore) {
                bestScore = score;
                bestTarget = { id, ...enemy };
            }
        });
        return bestTarget;
    }

    decide(world) {
        this.world = world;
        const currentStep = world?.step || 0;
        
        if (this.mentalMap.targetPriority) {
            const targetExists = (world?.enemies || []).some(e => 
                e.id === this.mentalMap.targetPriority.id && e.alive
            );
            if (!targetExists) {
                this.mentalMap.targetPriority = null;
                this._targetDeathFrame = currentStep;
            }
        }
        
        this._updateMentalMap(world);
        
        const inputs = this.getInputs(world);
        const combatEvents = this._combatEvents.length > 0 ? [...this._combatEvents] : null;
        const cortexRes = this.net.forward(inputs, this.cumulativeReward * 0.01, combatEvents);
        this._combatEvents = [];
        const D = cortexRes.output;
        
        const behaviors = {
            forward: Utils.clamp(D[0], 0, 1),
            turn: Utils.clamp(D[1], -1, 1),
            attack: D[2],
            dodge: D[3]
        };
        
        const visibleEnemies = (world?.enemies || []).filter(e => e?.alive && e.team !== this.team);
        const allies = (world?.enemies || []).filter(e => e?.alive && e.team === this.team && e.id !== this.id);
        
        if (visibleEnemies.length === 0) {
            behaviors.forward = 0.7;
            behaviors.turn = Math.sin(currentStep * 0.02) * 0.3;
            this.predictedIntercept = null;
            this._moveAngle = null;
            
            this.lastDecision = {
                mode: 'explore',
                behaviors,                inputs,
                output: D,
                selectedTarget: null,
                prediction: cortexRes.predictedTrajectory,
                intrinsicReward: cortexRes.intrinsicReward
            };
            
            return { target: this.target, speed: this.moveSpeed, mode: 'explore', behaviors, inputs, output: D };
        }
        
        let selectedTarget = null;
        if (this.mentalMap.targetPriority) {
            selectedTarget = visibleEnemies.find(e => e.id === this.mentalMap.targetPriority.id);
        }
        
        if (!selectedTarget) {
            const priorityTargets = allies.filter(a => 
                a.mentalMap?.targetPriority && a._combatTimer > 0
            );
            if (priorityTargets.length >= 2) {
                const consensusTarget = priorityTargets[0].mentalMap.targetPriority.id;
                const targetMatch = priorityTargets.filter(a => 
                    a.mentalMap.targetPriority.id === consensusTarget
                ).length;
                if (targetMatch >= 2) {
                    selectedTarget = visibleEnemies.find(e => e.id === consensusTarget);
                }
            }
        }
        
        if (!selectedTarget && visibleEnemies.length > 0) {
            if (D[9] > 0.3) {
                selectedTarget = visibleEnemies.sort((a,b) => 
                    Utils.threatScore(this,b) - Utils.threatScore(this,a)
                )[0];
            } else {
                selectedTarget = visibleEnemies.sort((a,b) => 
                    Utils.dist(this,a) - Utils.dist(this,b)
                )[0];
            }
            
            const targetCount = new Map();
            allies.forEach(a => {
                if (a.mentalMap?.targetPriority) {
                    targetCount.set(a.mentalMap.targetPriority.id, 
                        (targetCount.get(a.mentalMap.targetPriority.id) || 0) + 1);
                }
            });
            
            const countOnTarget = targetCount.get(selectedTarget.id) || 0;            if (countOnTarget >= 2) {
                const freeTargets = visibleEnemies.filter(e => 
                    !targetCount.has(e.id) || targetCount.get(e.id) < 2
                );
                if (freeTargets.length > 0) {
                    selectedTarget = freeTargets[0];
                }
            }
            
            if (selectedTarget) {
                this.mentalMap.targetPriority = {
                    id: selectedTarget.id,
                    confidence: 1.0,
                    lastSeen: currentStep,
                    acquiredAt: this.mentalMap.targetPriority?.id === selectedTarget.id 
                        ? this.mentalMap.targetPriority.acquiredAt 
                        : currentStep
                };
            }
        }
        
        if (selectedTarget && !selectedTarget.alive) {
            this.mentalMap.targetPriority = null;
            selectedTarget = null;
        }
        
        if (selectedTarget) {
            const dist = Utils.dist(this, selectedTarget);
            const inArc = this.isPointInWeaponArc(selectedTarget);
            
            const relativeVelocity = Math.hypot(
                selectedTarget.vx - this.vx,
                selectedTarget.vy - this.vy
            );
            const closingSpeed = arenaConfig.agentMaxVelocity * 0.8 + relativeVelocity;
            const timeAhead = closingSpeed > 0 ? dist / closingSpeed : 0;
            
            const enemyAcceleration = 0.3;
            const enemyFutureX = selectedTarget.x + 
                (selectedTarget.vx || 0) * timeAhead + 
                0.5 * enemyAcceleration * timeAhead * timeAhead;
            const enemyFutureY = selectedTarget.y + 
                (selectedTarget.vy || 0) * timeAhead + 
                0.5 * enemyAcceleration * timeAhead * timeAhead;
            
            let blendFactor = 0.5;
            const hasWallIntercept = (world?.walls || []).some(w => {
                const distToIntercept = w instanceof Wall ? w.distanceToPoint(enemyFutureX, enemyFutureY) : Math.hypot(enemyFutureX - w.x, enemyFutureY - w.y);
                return distToIntercept < 44;
            });            if (hasWallIntercept) blendFactor = 0.2;
            let interceptX, interceptY;
            const rawInterceptX = selectedTarget.x * (1 - blendFactor) + enemyFutureX * blendFactor;
            const rawInterceptY = selectedTarget.y * (1 - blendFactor) + enemyFutureY * blendFactor;
            
            if (this.predictedIntercept) {
                const delta = Math.hypot(rawInterceptX - this.predictedIntercept.x, 
                                          rawInterceptY - this.predictedIntercept.y);
                const smoothFactor = delta > 100 ? 0.3 : (delta > 50 ? 0.5 : 0.7);
                interceptX = this.predictedIntercept.x * (1 - smoothFactor) + rawInterceptX * smoothFactor;
                interceptY = this.predictedIntercept.y * (1 - smoothFactor) + rawInterceptY * smoothFactor;
            } else {
                interceptX = rawInterceptX;
                interceptY = rawInterceptY;
            }
            
            const alliesOnTarget = allies.filter(a => 
                a.mentalMap?.targetPriority?.id === selectedTarget?.id && a._combatTimer > 0
            );
            if (alliesOnTarget.length > 0) {
                const avgAttackAngle = alliesOnTarget.reduce((sum, a) => {
                    return sum + Math.atan2(selectedTarget.y - a.y, selectedTarget.x - a.x);
                }, 0) / alliesOnTarget.length;
                
                const flankOffset = Math.PI / 2;
                const desiredAngle = avgAttackAngle + flankOffset;
                const orbitRadius = selectedTarget.weapon.range * 1.2;
                
                interceptX = interceptX * 0.5 + (selectedTarget.x + Math.cos(desiredAngle) * orbitRadius) * 0.5;
                interceptY = interceptY * 0.5 + (selectedTarget.y + Math.sin(desiredAngle) * orbitRadius) * 0.5;
            }
            
            this.predictedIntercept = {
                x: interceptX,
                y: interceptY,
                targetX: selectedTarget.x,
                targetY: selectedTarget.y,
                futureX: enemyFutureX,
                futureY: enemyFutureY
            };
            
            const angleToTarget = Math.atan2(selectedTarget.y - this.y, selectedTarget.x - this.x);
            const angleError = Utils.normalizeAngle(angleToTarget - this.facingAngle);
            
            const confidence = Math.max(0, Math.min(1, (D[8] || 0.5)));
            const turnMod = D[1] * confidence * 0.5;
            const trajectoryMod = D[9] * confidence * 0.3;
            
            behaviors.turn = Utils.clamp(
                (angleError / Math.PI) + turnMod + trajectoryMod,                -1, 1
            );
            
            const angleToIntercept = Math.atan2(interceptY - this.y, interceptX - this.x);
            this._moveAngle = angleToIntercept;
            
            const nearbyAllies = allies.filter(a => Utils.dist(this, a) < 100).length;
            const aggressionMultiplier = 1 + (nearbyAllies * 0.15);
            behaviors.forward = Utils.clamp((dist > 40 ? 0.9 : 0.3) * aggressionMultiplier, 0, 1);
            
            const attackRangeWithHysteresis = this._wasAttackingLastFrame 
                ? this.attackRange * 1.15 
                : this.attackRange;
            const shouldAttack = inArc && dist < attackRangeWithHysteresis && this.attackCooldown <= 0;
            
            if (shouldAttack !== this._wasAttackingLastFrame) {
                if (!this._attackToggleTimer) this._attackToggleTimer = 0;
                this._attackToggleTimer++;
                
                if (this._attackToggleTimer < 5) {
                    behaviors.attack = this._wasAttackingLastFrame ? 1.0 : 0;
                } else {
                    behaviors.attack = shouldAttack ? 1.0 : 0;
                    this._attackToggleTimer = 0;
                }
            } else {
                behaviors.attack = shouldAttack ? 1.0 : 0;
                this._attackToggleTimer = 0;
            }
            this._wasAttackingLastFrame = shouldAttack;
        } else {
            behaviors.forward = 0.7;
            behaviors.turn = Math.sin(currentStep * 0.02) * 0.3;
            this.predictedIntercept = null;
            this._moveAngle = null;
        }
        
        const turnForce = behaviors.turn * 0.15;
        this.facingAngle += turnForce;
        this.facingAngle = Utils.normalizeAngle(this.facingAngle);
        
        const moveForce = behaviors.forward * arenaConfig.agentAcceleration * arenaConfig.agentSpeed;
        this.moveVector = {
            x: Math.cos(this.facingAngle) * moveForce,
            y: Math.sin(this.facingAngle) * moveForce
        };
        
        this.lastDecision = {
            mode: selectedTarget ? 'combat' : 'explore',
            behaviors,            inputs,
            output: D,
            selectedTarget,
            prediction: cortexRes.predictedTrajectory,
            intrinsicReward: cortexRes.intrinsicReward
        };
        
        return { target: this.target, speed: this.moveSpeed, mode: selectedTarget ? 'combat' : 'explore', behaviors, inputs, output: D };
    }

    _updateMentalMap(world) {
        const viewRadius = arenaConfig.viewRadius || 250;
        const now = world?.step || 0;
        const deadTargets = [];
        
        for (const entity of world?.enemies || []) {
            if (!entity?.alive || entity.id === this.id || entity.team === this.team) continue;
            
            const dx = entity.x - this.x;
            const dy = entity.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist <= viewRadius) {
                this.mentalMap.enemies.set(entity.id, {
                    dx: dx / viewRadius,
                    dy: dy / viewRadius,
                    dist: dist / viewRadius,
                    hp: entity.health / entity.stats.maxHealth,
                    weapon: entity.weaponType,
                    vx: entity.vx / 15,
                    vy: entity.vy / 15,
                    threat: Utils.threatScore(this, entity),
                    confidence: 1.0,
                    lastSeen: now,
                    isAlive: true
                });
            }
        }
        
        this.mentalMap.enemies.forEach((value, key) => {
            const targetEntity = (world?.enemies || []).find(e => e.id === key);
            if (!targetEntity || !targetEntity.alive) {
                deadTargets.push(key);
                return;
            }
            
            value.confidence *= 0.98;
            if (value.confidence < 0.1 || now - value.lastSeen > 200) {
                deadTargets.push(key);
            }        });
        
        for (const key of deadTargets) {
            if (this.mentalMap.targetPriority?.id === key) {
                this.mentalMap.targetPriority = null;
                this._targetSwitchFrame = now;
            }
            this.mentalMap.enemies.delete(key);
        }
        
        this.mentalMap.lastUpdate = now;
    }

    move(decision, walls, dt, otherAgents) {
        if (!isFinite(this.x) || !isFinite(this.y)) {
            console.error(`Agent ${this.id} has invalid position`);
            this.x = 425; this.y = 290;
        }
        
        if (!isFinite(this.vx) || !isFinite(this.vy)) {
            this.vx = 0; this.vy = 0;
        }
        
        if (!isFinite(this.facingAngle)) {
            this.facingAngle = 0;
        }
        
        const b = decision.behaviors;
        const moveForce = Math.max(0, b.forward) * arenaConfig.agentAcceleration * arenaConfig.agentSpeed;
        
        const moveAngle = this._moveAngle || this.facingAngle;
        
        const moveX = Math.cos(moveAngle) * moveForce * dt;
        const moveY = Math.sin(moveAngle) * moveForce * dt;
        
        this.vx += moveX;
        this.vy += moveY;
        const turnForce = b.turn * 0.15;
        this.facingAngle += turnForce * dt;
        this.facingAngle = Utils.normalizeAngle(this.facingAngle);
        this.vx *= arenaConfig.agentFriction;
        this.vy *= arenaConfig.agentFriction;
        
        const velSq = this.vx*this.vx + this.vy*this.vy;
        const maxVelSq = arenaConfig.agentMaxVelocity * arenaConfig.agentMaxVelocity;
        if (velSq > maxVelSq) {
            const scale = arenaConfig.agentMaxVelocity / Math.sqrt(velSq);
            this.vx *= scale; this.vy *= scale;
        }
        this.x += this.vx * dt;        this.y += this.vy * dt;
        
        // PATCH E.3: Wall collision with line segments
        for (const wall of walls) {
            const dist = wall instanceof Wall ? wall.distanceToPoint(this.x, this.y) : Utils.dist(this, wall);
            const minDist = arenaConfig.agentCollisionRadius + (wall.thickness || 14) / 2;
            if (dist < minDist) {
                if (wall instanceof Wall) {
                    const pushX = wall.normal.x * (minDist - dist);
                    const pushY = wall.normal.y * (minDist - dist);
                    this.x += pushX;
                    this.y += pushY;
                } else {
                    const push = Utils.normalize(this.x - wall.x, this.y - wall.y);
                    this.x += push.x * (minDist - dist);
                    this.y += push.y * (minDist - dist);
                }
                this.vx *= 0.7; this.vy *= 0.7;
            }
        }
        
        const teamAgents = otherAgents.filter(a => a.team === this.team && a.alive);
        for (const ally of teamAgents) {
            if (ally.id === this.id) continue;
            const dist = Utils.dist(this, ally);
            if (dist < 60 && dist > 0) {
                const pushAngle = Math.atan2(this.y - ally.y, this.x - ally.x);
                const pushStrength = (60 - dist) / 60 * 0.5;
                this.vx += Math.cos(pushAngle) * pushStrength;
                this.vy += Math.sin(pushAngle) * pushStrength;
            }
        }
        
        if (otherAgents?.length) {
            for (const other of otherAgents) {
                if (other.id === this.id || !other.alive) continue;
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const minDist = arenaConfig.agentCollisionRadius * 2;
                if (dist < minDist && dist > 0.001) {
                    const nx = dx / dist, ny = dy / dist;
                    const penetration = minDist - dist;
                    const separation = penetration * 0.5;
                    this.x -= nx * separation;
                    this.y -= ny * separation;
                    other.x += nx * separation;
                    other.y += ny * separation;
                    const relVelX = this.vx - other.vx;
                    const relVelY = this.vy - other.vy;                    const relVelNormal = relVelX * nx + relVelY * ny;
                    if (relVelNormal < 0) {
                        const impulse = relVelNormal * arenaConfig.PHYSICS.COLLISION_ELASTICITY;
                        this.vx -= impulse * nx;
                        this.vy -= impulse * ny;
                        other.vx += impulse * nx;
                        other.vy += impulse * ny;
                    }
                }
            }
        }
        
        const r = arenaConfig.agentCollisionRadius;
        this.x = Utils.clamp(this.x, r, 850 - r);
        this.y = Utils.clamp(this.y, r, 580 - r);
        
        if (!isFinite(this.x) || !isFinite(this.y)) {
            console.error(`Agent ${this.id} position overflow after move`);
            this.x = 425; this.y = 290;
        }
        
        if (Math.abs(this._knockbackVelocity.x) > 0.1 || Math.abs(this._knockbackVelocity.y) > 0.1) {
            this.vx += this._knockbackVelocity.x;
            this.vy += this._knockbackVelocity.y;
            this._knockbackVelocity.x *= arenaConfig.PHYSICS.FRICTION_GROUND;
            this._knockbackVelocity.y *= arenaConfig.PHYSICS.FRICTION_GROUND;
            if (Math.abs(this._knockbackVelocity.x) < 0.05) this._knockbackVelocity.x = 0;
            if (Math.abs(this._knockbackVelocity.y) < 0.05) this._knockbackVelocity.y = 0;
        }
        this.velocity.x = this.vx;
        this.velocity.y = this.vy;
    }

    _applyKnockback(target, aggression, weapon) {
        const baseKB = weapon.knockback || 8.0;
        const kbType = weapon.knockbackType || 'impact';
        const kbStrength = baseKB + aggression * 3;
        const knockbackDir = Utils.normalize(target.x - this.x, target.y - this.y);
        const mass = arenaConfig.PHYSICS.KNOCKBACK_MASS;
        const recoilStrength = weapon.recoilStrength || 0.15;
        switch(kbType) {
            case 'impact':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength / mass;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'heavy':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 1.8 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 1.8 / mass;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);                target._heavyHit = 20;
                break;
            case 'slash':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength / mass;
                target._knockbackVelocity.x += -knockbackDir.y * kbStrength * 0.4 / mass;
                target._knockbackVelocity.y += knockbackDir.x * kbStrength * 0.4 / mass;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'thrust':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 1.2 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 1.2 / mass;
                target._pierced = 15;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'stagger':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 0.5 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 0.5 / mass;
                target._knockbackVelocity.x += Utils.rand(-1, 1) * 2;
                target._knockbackVelocity.y += Utils.rand(-1, 1) * 2;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'pulse':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 0.8 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 0.8 / mass;
                target._pulseEffect = 25;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'quick':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 0.3 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 0.3 / mass;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'continuous':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 0.4 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 0.4 / mass;
                target._continuousKB = Math.min(1, (target._continuousKB || 0) + 0.25);
                target._knockbackVelocity.x *= (1 - target._continuousKB * 0.15);
                target._knockbackVelocity.y *= (1 - target._continuousKB * 0.15);
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
        }
        const maxKB = arenaConfig.PHYSICS.MAX_VELOCITY * 1.5;
        target._knockbackVelocity.x = Utils.clamp(target._knockbackVelocity.x, -maxKB, maxKB);
        target._knockbackVelocity.y = Utils.clamp(target._knockbackVelocity.y, -maxKB, maxKB);
        this._knockbackVelocity.x -= knockbackDir.x * kbStrength * recoilStrength / mass;
        this._knockbackVelocity.y -= knockbackDir.y * kbStrength * recoilStrength / mass;
    }
    calculateReward(world, decision) {
        let reward = 0;        const inputs = decision.inputs;
        const enemiesNearby = inputs[2] < 0.5;
        
        if (!enemiesNearby) {
            const moved = Math.hypot(this.x - this.lastPos.x, this.y - this.lastPos.y);
            const cellKey = `${Math.floor(this.x / 50)},${Math.floor(this.y / 50)}`;
            if (!this.permanent.memory.visited.has(cellKey)) {
                reward += arenaConfig.TACTICAL.EXPLORATION_BONUS;
                this.permanent.memory.visited.add(cellKey);
            }
            if (moved > 2) {
                reward += 0.02;
            }
            if (Math.abs(decision.behaviors.turn) > 0.85 && moved < 0.3) {
                reward -= arenaConfig.TACTICAL.SPINNING_PENALTY;
            }
            const allies = (world?.enemies || []).filter(a => 
                a?.alive && a.team === this.team && a.id !== this.id
            );
            if (allies.length > 0) {
                const avgDistToAllies = allies.reduce((sum, a) => sum + Utils.dist(this, a), 0) / allies.length;
                if (avgDistToAllies > 150) {
                    reward += 0.03;
                }
            }
        }
        
        if (enemiesNearby) {
            if (this._lastHitDealt > 0) {
                reward += this._lastHitDealt * 1.5;
                const predicted = this.net.predictedPos60;
                const distToPredicted = Utils.dist(this, predicted);
                if (distToPredicted < 40) {
                    reward += 0.50;
                }
            }
            if (this._lastHitReceived > 0) {
                reward -= this._lastHitReceived * 0.15;
            }
            
            const predError = this.net.predictionError60 || 0;
            if (predError < 30) {
                reward += 0.10;
            } else {
                reward -= 0.05;
            }
            
            const allies = (world?.enemies || []).filter(a => 
                a?.alive && a.team === this.team && a.id !== this.id
            );            const alliesOnTarget = allies.filter(a => 
                a.mentalMap?.targetPriority?.id === decision.selectedTarget?.id
            ).length;
            if (alliesOnTarget >= 3) {
                reward -= 0.10;
            }
            
            const allyD9 = allies.map(a => a.lastDecision?.output?.[9] || 0);
            if (allyD9.length > 1) {
                const d9Variance = allyD9.reduce((s,v) => s + Math.pow(v - allyD9[0], 2), 0) / allyD9.length;
                if (d9Variance > 0.3) {
                    reward += 0.05;
                }
            }
        }
        
        const moved = Math.hypot(this.x - this.lastPos.x, this.y - this.lastPos.y);
        if (moved > 1.0) { reward += 0.01; this.stuckCounter = 0; }
        else { this.stuckCounter++; if (this.stuckCounter > 30) reward -= 0.05; }
        
        if (arenaConfig.enableTactical && this.world?.walls?.length) {
            const nearestWall = this.world.walls.reduce((closest, w) => {
                const d = w instanceof Wall ? w.distanceToPoint(this.x, this.y) : Utils.dist(this, w);
                return d < (closest instanceof Wall ? closest.distanceToPoint(this.x, this.y) : Utils.dist(closest || {x:9999,y:9999}, this)) ? w : closest;
            });
            
            const wallDist = nearestWall ? (nearestWall instanceof Wall ? nearestWall.distanceToPoint(this.x, this.y) : Utils.dist(this, nearestWall)) : 999;
            
            if (wallDist < 50 && wallDist > 25) {
                reward += 0.03;
            }
            
            if (wallDist > 100 && this._inEnemyArc) {
                reward -= arenaConfig.TACTICAL.EXPOSURE_PENALTY * 0.5;
            }
        }
        
        const wallDist = (world?.walls || []).length ? Math.min(...world.walls.map(w => w instanceof Wall ? w.distanceToPoint(this.x, this.y) : Utils.dist(this, w))) : 999;
        if (wallDist < 80) reward -= arenaConfig.TACTICAL.WALL_PENALTY * (1 - wallDist / 80);
        if (wallDist < 40) reward -= 0.20;
        
        const healthRatio = this.health / this.stats.maxHealth;
        if (healthRatio < 0.15) reward -= 0.10;
        
        if (decision.intrinsicReward) {
            reward += decision.intrinsicReward;
        }
        this.lastPos = { x: this.x, y: this.y };
        reward = isFinite(reward) ? reward : 0;
        this.cumulativeReward = Utils.clamp(isFinite(this.cumulativeReward) ? this.cumulativeReward + reward : reward, -100, 500);        
        return reward;
    }

    learn(reward, decision, nextInputs = null) {
        if (!decision || !arenaConfig.enableTraining) return;
        const currentValue = decision.value;
        const nextValue = nextInputs ? this.critic.forward(nextInputs) : 0;
        const criticResult = this.critic.update(decision.inputs, reward, nextValue);
        const tdResult = this.net.tdLearn(decision.inputs, decision.output, reward, currentValue, nextValue, decision.modeProbs ? Utils.logSoftmax(decision.modeProbs.map(p => Math.log(Math.max(p, 1e-10)) * 10), 1) : null);
        this.net.updateDiagnostics({ win: null, collected: false, survival: this.health / this.stats.maxHealth, reward });
        if (reward > 3 && arenaConfig.enableSkillEvolution) this.updatePermanentSkills(reward, decision.mode, arenaConfig.skillGrowthRate);
        if (reward > 4) this.updateMuscleMemory(decision.output, reward);
        this.learningBuffer.states.push(decision.inputs);
        this.learningBuffer.actions.push(decision.output);
        this.learningBuffer.rewards.push(reward);
        this.learningBuffer.values.push(currentValue);
        if (this.learningBuffer.states.length >= this.learningBuffer.maxBuffer) this._batchLearn();
    }

    _batchLearn() {
        if (!arenaConfig.enableTraining) { this._clearLearningBuffer(); return; }
        const advantages = Utils.computeGAE(this.learningBuffer.rewards, this.learningBuffer.values, 0, this.net.gamma, this.net.lambda);
        for (let t = 0; t < advantages.length; t++) {
            if (this.lastDecision?.modeProbs && arenaConfig.enablePolicySelector) {
                const modeIdx = 0;
                const enemies = (this._lastWorld?.enemies || []).filter(e => e && e.id !== this.id && e.alive && e.team !== this.team);
                const context = [
                    enemies.length > 0 ? Utils.clamp(Utils.dist(this, enemies[0]?.agent || enemies[0]) / 200, 0, 1) : 1,
                    (this._lastWorld?.walls || []).length ? Utils.clamp(Math.min(...this._lastWorld.walls.map(w => w instanceof Wall ? w.distanceToPoint(this.x, this.y) : Utils.dist(this, w))) / 60, 0, 1) : 0,
                    this.health / this.stats.maxHealth,
                    Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[5], 0.5), 0, 1),
                    Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[6], 0.5), 0, 1),
                    Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[7], 0.5), 0, 1),
                    this.permanent.skills.hunting,
                    this.permanent.skills.fleeing
                ];
                this.policySelector.update(context, this.skillEmbedding, modeIdx, advantages[t]);
            }
        }
        this._clearLearningBuffer();
    }

    _clearLearningBuffer() {
        this.learningBuffer = { states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [], maxBuffer: 32 };
        this._lastWorld = null;
    }
    updatePermanentSkills(reward, mode, skillGrowthRate) {
        if (reward <= 3 || !arenaConfig.enableSkillEvolution) return;
        const skillKey = 'combat';        if (skillKey && this.permanent.skills[skillKey] !== undefined) {
            const growth = skillGrowthRate * reward * arenaConfig.EVOLUTION.COMBAT_SKILL_GROWTH;
            this.permanent.skills[skillKey] = Utils.clamp(this.permanent.skills[skillKey] + growth, 0, 1);
            this.skillEmbedding = [this.permanent.skills.hunting, this.permanent.skills.fleeing, this.permanent.skills.combat, this.permanent.skills.exploring, this.permanent.skills.avoiding];
        }
    }

    updateMuscleMemory(outputs, reward) {
        if (reward < 4) return;
        for (let i = 0; i < Math.min(16, outputs.length); i++) {
            const diff = Math.abs(outputs[i] - this.permanent.muscleMemory[i]);
            if (diff > 0.12 && Math.abs(outputs[i]) > 0.4) {
                this.permanent.muscleMemory[i] = Utils.lerp(this.permanent.muscleMemory[i], outputs[i], 0.08);
            }
        }
    }

    updatePredictiveMemory(world) {
        this.predictive.shortTerm.positions.push({ x: this.x, y: this.y });
        if (this.predictive.shortTerm.positions.length > 20) this.predictive.shortTerm.positions.shift();
        const enemies = (world?.enemies || []).filter(e => e && e.id !== this.id && e.alive && e.team !== this.team);
        if (enemies.length > 0) {
            const enemy = enemies[0];
            this.enemyPredictor.history.push({ x: enemy.x, y: enemy.y, vx: enemy.vx, vy: enemy.vy, step: world.step || 0 });
            if (this.enemyPredictor.history.length > 50) this.enemyPredictor.history.shift();
        }
    }

    selectCombatTactic(enemyDistance, enemyHealth, myHealth, enemyPrediction) {
        if (enemyPrediction === 'fleeing') return 'aggressive';
        if (enemyPrediction === 'aggressive') return myHealth < 0.4 ? 'defensive' : 'kite';
        if (enemyHealth < 0.3) return 'aggressive';
        if (myHealth < 0.3) return 'defensive';
        if (enemyDistance < 20) return 'bait';
        return 'adaptive';
    }

    decideCombatAction(enemy, world) {
        const distance = Utils.dist(this, enemy);
        const prediction = this.enemyPredictor.predictNextAction();
        if (!this.socialMemory.interactions.has(enemy.id)) this.socialMemory.interactions.set(enemy.id, { fights: 0, wins: 0, trust: 0 });
        const record = this.socialMemory.interactions.get(enemy.id);
        record.fights++;
        const enemyHealth = enemy.health / enemy.stats.maxHealth, myHealth = this.health / this.stats.maxHealth;
        if (enemyHealth < 0.3 && myHealth > 0.7) this.currentTactic = record.trust > 0 ? 'merciful' : 'aggressive';
        else if (enemyHealth < 0.3 && myHealth < 0.3) this.currentTactic = Math.random() < 0.8 ? 'aggressive' : 'defensive';
        else this.currentTactic = this.selectCombatTactic(distance, enemyHealth, myHealth, prediction);
        this.fightOpponent = enemy.id;
        this.fightStartTime = Date.now();
        return this.currentTactic;    }

    applyEvolutionPoints() {
        if (this.evolutionPoints <= 0) return;
        const output = this.net.D || this.lastDecision?.output || [0.5, 0.5, 0.5, 0.5];
        const statsMap = [
            { key: 'maxHealth', val: output[12] || 0.5 },
            { key: 'damage', val: output[13] || 0.5 },
            { key: 'dodgeChance', val: output[14] || 0.5 },
            { key: 'fireRate', val: output[15] || 0.5 }
        ];
        statsMap.sort((a, b) => b.val - a.val);
        const chosen = statsMap.slice(0, 2);
        for (const pick of chosen) {
            this._applyStatBonus(pick.key, 1);
        }
        this.evolutionPoints = 0;
        Logger.log(`‚¨ÜÔ∏è ${this.id} —É–ª—É—á—à–∏–ª: ${chosen.map(c=>c.key).join(', ')}`, 'success');
    }

    _applyStatBonus(stat, points) {
        const safePoints = Math.max(0, Math.floor(points));
        if (safePoints <= 0) return;
        const MIN_STATS = { maxHealth: 50, damage: 1, dodgeChance: 0, fireRate: 5 };
        const MAX_STATS = { maxHealth: 300, damage: 15, dodgeChance: 0.5, fireRate: 60 };
        switch(stat) {
            case 'maxHealth':
                this.stats.maxHealth = Utils.clamp(this.stats.maxHealth + safePoints * 10, MIN_STATS.maxHealth, MAX_STATS.maxHealth);
                this.health = Math.min(this.stats.maxHealth, this.health + safePoints * 10);
                break;
            case 'damage':
                this.stats.damage = Utils.clamp(this.stats.damage + safePoints * 1, MIN_STATS.damage, MAX_STATS.damage);
                break;
            case 'dodgeChance':
                this.stats.dodgeChance = Utils.clamp(this.stats.dodgeChance + safePoints * 0.1, MIN_STATS.dodgeChance, MAX_STATS.dodgeChance);
                break;
            case 'fireRate':
                this.stats.fireRate = Utils.clamp(this.stats.fireRate + safePoints * 3, MIN_STATS.fireRate, MAX_STATS.fireRate);
                break;
            default: return;
        }
        this.lastMutationType = stat;
    }

    getLearningMetrics() {
        return {
            avgTDError: this.net._stats?.tdErrorHistory?.reduce((a,b)=>a+b,0)/Math.max(1,this.net._stats?.tdErrorHistory?.length || 1) || 0,
            avgPredictionError: this.net._computeAvgPredError?.() || 0,
            winRate: this.wins / Math.max(1, this.wins + this.deaths),
            avgDamage: this._totalDamageDealt / Math.max(1, this._totalAttacks),            accuracy: this._successfulHits / Math.max(1, this._totalAttacks),
            tacticalRate: this._tacticalHits / Math.max(1, this._successfulHits)
        };
    }

    evolve(mutationRate = 0.1) {
        if (!arenaConfig.enableEvolution) return 0;
        const actualRate = this._learnFromWinner ? arenaConfig.EVOLUTION.MUTATION_ON_DEATH : mutationRate;
        const mutations = this.net.mutate(actualRate, 0.15);
        if (this.critic?._W1) {
            this.critic._W1.forEach(row => {
                if (!row) return;
                row.forEach((v, i) => {
                    if (this.net._rng.next() < actualRate) {
                        row[i] += (this.net._rng.next() * 2 - 1) * 0.15;
                        row[i] = Utils.clamp(row[i], -2, 2);
                    }
                });
            });
        }
        this.mutations += mutations;
        return mutations;
    }

    reset(x, y) {
        this.net.restoreEmotionalMemory();
        this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.velocity = { x: 0, y: 0 };
        this.health = this.stats.maxHealth; this.stuckCounter = 0; this.lastPos = { x, y };
        this.cumulativeReward = 0; this.mode = 'combat'; this.target = { x, y }; this.trail = [];
        this.predictive.confidence = 0.5; this.predictive.predictionError = 0; this.attackCooldown = 0;
        this._clearLearningBuffer();
        this.predictive.shortTerm = { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] };
        this._lastHitDealt = 0; this._knockbackVelocity = { x: 0, y: 0 }; this._stunTimer = 0; this._weaponEffectTimer = 0;
        this._heavyHit = 0; this._pierced = 0; this._pulseEffect = 0; this._continuousKB = 0;
        this._forcedCombatTimer = arenaConfig.EVOLUTION.FORCED_COMBAT_AFTER_DEATH;
        this._recentArcExposure = []; this._inEnemyArc = false; this._lastThreatAssessment = null;
        this.facingAngle = 0; this._angleToEnemy = 0; this._wallDistance = 999;
        this._isFacingEnemy = false; this._attackValid = false;
        this._exposure = { level: 0, type: 'none' }; this._inCombatRange = false;
        this._combatEvents = [];
        this.decisionCommitment = { current: null, minFrames: { attack: 45, retreat: 30, flank: 60, approach: 30 } };
        this.actionState = { phase: 'idle', startTime: 0, expectedDuration: 0, targetPosition: null, completed: false };
        this.world = null;
        this.moveVector = { x: 0, y: 0 };
        this.moveSpeed = 1;
        this.mentalMap = { enemies: new Map(), lastUpdate: 0, targetPriority: null };
        this.assignedTargetId = null;
        this.assignedRole = 'assault';
        this.explorationTarget = null;
        this._combatTimer = 0;        this.predictedIntercept = null;
        this._moveAngle = null;
        this._wasAttackingLastFrame = false;
        this._attackToggleTimer = 0;
        this._targetDeathFrame = null;
        this._targetSwitchFrame = null;
    }

    learnFromWinner(winner) {
        if (!winner || !arenaConfig.enableWeightInheritance) return;
        this._learnFromWinner = true;
        const inheritRate = arenaConfig.EVOLUTION.LEARN_FROM_WINNER_RATE;
        const inheritWeights = (child, parent) => {
            if (!child || !parent) return;
            for (let i = 0; i < Math.min(child.length, parent.length); i++) {
                if (Array.isArray(child[i]) && Array.isArray(parent[i])) {
                    for (let j = 0; j < Math.min(child[i].length, parent[i].length); j++) {
                        if (Math.random() < inheritRate) child[i][j] = parent[i][j];
                    }
                }
            }
        };
        inheritWeights(this.net.W_C, winner.net.W_C);
        inheritWeights(this.net.W_D, winner.net.W_D);
        inheritWeights(this.net.W_P, winner.net.W_P);
        this.socialMemory.killerHistory.push({ killer: winner.id, weapon: winner.weaponType, mode: winner.mode, step: Date.now(), myHealth: this.health / this.stats.maxHealth, theirHealth: winner.health / winner.stats.maxHealth });
        if (this.socialMemory.killerHistory.length > 10) this.socialMemory.killerHistory.shift();
        Logger.log(`üìö ${this.id.toUpperCase()} —É—á–∏—Ç—Å—è —É ${winner.id.toUpperCase()} (${winner.weapon.icon} ${winner.weapon.name})`, 'learning');
    }

    draw(ctx, showVision = false, showTrail = true) {
        if (!isFinite(this.x) || !isFinite(this.y)) return;
        if (!isFinite(this.facingAngle)) return;
        
        if (showTrail && this.trail.length > 1) {
            ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for (let i = 1; i < this.trail.length; i++) {
                const t = this.trail[i];
                if (!isFinite(t.x) || !isFinite(t.y)) continue;
                const alpha = 1 - t.age / 80;
                ctx.strokeStyle = this.color + Math.floor(alpha * 40).toString(16).padStart(2, '0');
                ctx.lineTo(t.x, t.y);
            }
            ctx.stroke();
        }
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.facingAngle);
        let drawColor = this.color;
        if (this._lastHitReceived > 0) drawColor = '#ff8888';
        else if (this.lastMutationType === 'dmg') drawColor = '#ff4444';
        else if (this.lastMutationType === 'spd') drawColor = '#4444ff';        else if (this.lastMutationType === 'hp') drawColor = '#44ff44';
        else if (this.lastMutationType === 'dod') drawColor = '#aa88ff';
        ctx.fillStyle = drawColor; ctx.beginPath();
        ctx.moveTo(this.bodyVertices[0].x, this.bodyVertices[0].y);
        for (let i = 1; i < this.bodyVertices.length; i++) ctx.lineTo(this.bodyVertices[i].x, this.bodyVertices[i].y);
        ctx.closePath(); ctx.fill();
        ctx.strokeStyle = this._knockbackVelocity.x !== 0 || this._knockbackVelocity.y !== 0 ? '#ff0000' : '#ffffff';
        ctx.lineWidth = this._knockbackVelocity.x !== 0 || this._knockbackVelocity.y !== 0 ? 3 : 2;
        ctx.stroke();
        const mount = this.weapon.mountOffset || { x: 24, y: 0 };
        ctx.fillStyle = this.weapon.color || '#ffaa00'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(this.weapon.icon, mount.x, mount.y);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(28, 0); ctx.stroke();
        ctx.restore();
        ctx.fillStyle = '#fff'; ctx.font = '9px monospace'; ctx.textAlign = 'center';
        ctx.fillText(`HP:${Math.round(this.stats.maxHealth)} DMG:${this.stats.damage}`, this.x, this.y - 32);
        ctx.fillText(`${this.weapon.name} W:${this.wins}`, this.x, this.y - 22); ctx.textAlign = 'left';
        if (this.health < this.stats.maxHealth) {
            ctx.fillStyle = '#222'; ctx.fillRect(this.x - 22, this.y - 38, 44, 4);
            ctx.fillStyle = this.health > this.stats.maxHealth / 2 ? '#00ff9d' : '#ff5577';
            ctx.fillRect(this.x - 22, this.y - 38, 44 * (this.health / this.stats.maxHealth), 4);
        }
        ctx.fillStyle = this.predictive.confidence > 0.7 ? '#00ff9d' : (this.predictive.confidence < 0.4 ? '#ff5577' : '#ffaa00');
        ctx.beginPath(); ctx.arc(this.x + 14, this.y - 14, 3, 0, Math.PI * 2); ctx.fill();
        
        if (showVision) {
            const viewRadius = arenaConfig.viewRadius || 250;
            const inputs = this.lastDecision?.inputs || [];
            const enemiesNearby = inputs[2] < 0.5;
            
            ctx.strokeStyle = enemiesNearby ? 'rgba(255, 50, 50, 0.4)' : 'rgba(0, 255, 157, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, viewRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(
                this.x + Math.cos(this.facingAngle) * 40,
                this.y + Math.sin(this.facingAngle) * 40
            );
            ctx.stroke();
            
            if (this.lastDecision?.selectedTarget?.alive && this.predictedIntercept) {
                const target = this.lastDecision.selectedTarget;
                const pred = this.predictedIntercept;
                                if (isFinite(target.x) && isFinite(target.y) && 
                    isFinite(pred.x) && isFinite(pred.y)) {
                    
                    ctx.strokeStyle = this.team === 'blue' ? '#00d4ff' : '#ff5577';
                    ctx.lineWidth = 5;
                    ctx.setLineDash([8, 4]);
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(target.x, target.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.strokeStyle = 'rgba(0, 255, 157, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(target.x, target.y);
                    ctx.lineTo(pred.futureX, pred.futureY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                    ctx.beginPath();
                    ctx.arc(pred.x, pred.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 3]);
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(pred.x, pred.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.facingAngle);
            
            ctx.fillStyle = this.lastDecision?.inWeaponArc ? 'rgba(255, 0, 0, 0.25)' : 'rgba(255, 170, 0, 0.15)';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, this.attackRange, -this.weapon.arcAngle/2, this.weapon.arcAngle/2);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = this.lastDecision?.inWeaponArc ? 'rgba(255, 0, 0, 0.8)' : 'rgba(255, 170, 0, 0.5)';
            ctx.lineWidth = 2;            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, this.attackRange, -this.weapon.arcAngle/2, this.weapon.arcAngle/2);
            ctx.stroke();
            
            ctx.restore();
            
            if (this.lastDecision?.behaviors?.attack > 0.8 && this.attackCooldown > this.stats.fireRate - 5) {
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 10, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = '#ff0';
                ctx.font = 'bold 12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('‚öîÔ∏è ATTACK', this.x, this.y - 35);
            }
        }
        
        if (this.trail.length === 0 || this.trail[this.trail.length - 1].age > 4) {
            if (isFinite(this.x) && isFinite(this.y)) {
                this.trail.push({ x: this.x, y: this.y, age: 0 });
                if (this.trail.length > 35) this.trail.shift();
            }
        }
        this.trail.forEach(t => t.age++);
        if (Math.abs(this._knockbackVelocity.x) > 1 || Math.abs(this._knockbackVelocity.y) > 1) {
            ctx.strokeStyle = 'rgba(255,50,50,0.8)'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 8, 0, Math.PI * 2); ctx.stroke();
        }
        if (this._stunTimer > 0) {
            ctx.strokeStyle = 'rgba(255,255,0,0.6)'; ctx.setLineDash([2, 3]);
            ctx.beginPath(); ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 10, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]);
        }
        if (this._forcedCombatTimer > 0) {
            ctx.strokeStyle = 'rgba(255,0,0,0.5)'; ctx.setLineDash([5, 5]);
            ctx.beginPath(); ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 12, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]);
        }
        if (window.arenaGame?.debug) {
            ctx.strokeStyle = 'rgba(255,255,0,0.4)'; ctx.setLineDash([3, 2]);
            ctx.beginPath(); ctx.arc(this.x, this.y, arenaConfig.agentCollisionRadius, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]);
        }
        if (window.arenaGame?.debug) {
            ctx.strokeStyle = 'rgba(0, 255, 100, 0.6)'; ctx.lineWidth = 1.5; ctx.beginPath();
            ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.velocity.x * 4, this.y + this.velocity.y * 4); ctx.stroke();
        }
        if (window.arenaGame?.debug) {
            ctx.fillStyle = this._exposure.type === 'back' ? '#ff0000' : (this._exposure.type === 'flank' ? '#ffaa00' : '#00ff9d');            ctx.font = '8px monospace'; ctx.textAlign = 'center';
            ctx.fillText(this._exposure.type.toUpperCase(), this.x, this.y - 45);
        }
        
        if (arenaConfig.enableLowHealthHint && this.health < this.stats.maxHealth * 0.5 && this.alive) {
            ctx.save();
            ctx.translate(this.x, this.y - 50);
            
            const pulse = 0.7 + Math.sin(this._stunTimer * 0.3) * 0.3;
            ctx.globalAlpha = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
            
            ctx.fillStyle = 'rgba(255, 68, 68, 0.3)';
            ctx.beginPath();
            ctx.arc(0, 0, 18 * pulse, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('!', 0, -2);
            
            if (this.health < this.stats.maxHealth * 0.25 || window.arenaGame?.debug) {
                ctx.font = '8px monospace';
                ctx.fillStyle = '#ffaa00';
                ctx.fillText('üß™ –∏—â–∏', 0, 14);
            }
            
            ctx.restore();
        }
    }

    getDebugInfo() {
        const metrics = this.getLearningMetrics();
        const attention = this.interpretAttention();
        const enemyIntent = this.predictEnemyIntent((this._lastWorld?.enemies || []).find(e => e?.id !== this.id && e?.alive && e?.team !== this.team)?.agent);
        const emotions = this.net.getEmotions();
        const emotionalState = this.net.emotionalState.current;
        const grudge = this.net.emotionMemory.grudge.size > 0 ?
            Array.from(this.net.emotionMemory.grudge.values()).reduce((a, b) => a + b, 0) / this.net.emotionMemory.grudge.size : 0;
        const D = this.lastDecision?.output || [];
        const inputs = this.lastDecision?.inputs || [];
        const enemiesNearby = inputs[2] < 0.5;
        return {
            mode: enemiesNearby ? 'üî• –ë–û–ô' : 'üîç –†–ê–ó–í–ï–î–ö–ê',
            weapon: this.weapon.icon + ' ' + this.weapon.name,
            target: `${Math.round(this.target.x)},${Math.round(this.target.y)}`,
            speed: Math.hypot(this.velocity.x, this.velocity.y).toFixed(2),
            D0_forward: D[0]?.toFixed(2) || '‚Äî',
            D1_turn: D[1]?.toFixed(2) || '‚Äî',            D2_attack: D[2]?.toFixed(2) || '‚Äî',
            D3_dodge: D[3]?.toFixed(2) || '‚Äî',
            D4_aggression: D[4]?.toFixed(2) || '‚Äî',
            D5_focus: D[5]?.toFixed(2) || '‚Äî',
            D6_defense: D[6]?.toFixed(2) || '‚Äî',
            D7_coordination: D[7]?.toFixed(2) || '‚Äî',
            D8_confidence: D[8]?.toFixed(2) || '‚Äî',
            D9_trajectory: D[9]?.toFixed(2) || '‚Äî',
            role: this.assignedRole || 'assault',
            health: `${Math.round(this.health)}/${this.stats.maxHealth}`,
            mutations: this.mutations, generation: this.generation,
            tdError: metrics.avgTDError.toFixed(4), winRate: metrics.winRate.toFixed(2),
            threat: attention.threat, flank: attention.flank, memoryConf: attention.prediction,
            reflexActive: this.net.S?.some?.(v => v > 0.8) ? 'YES' : 'NO',
            cortexEnergy: this.net.C ? (this.net.C.reduce((s,v) => s + Math.abs(v), 0) / this.net.DIM.DIM_C).toFixed(3) : '‚Äî',
            enemyIntent: enemyIntent.intent, intentConf: enemyIntent.confidence.toFixed(2),
            facing: (this.facingAngle * 180 / Math.PI).toFixed(0) + '¬∞',
            visitedCells: this.permanent.memory.visited.size,
            mentalMapEnemies: this.mentalMap.enemies.size,
            priorityTarget: this.mentalMap.targetPriority ? `${this.mentalMap.targetPriority.id?.substring(0,8)}...` : 'none',
            prediction: this.lastDecision?.prediction ? 
                `angle:${(this.lastDecision.prediction.angle*180/Math.PI).toFixed(0)}¬∞,conf:${this.lastDecision.prediction.confidence.toFixed(2)}` : '‚Äî',
            predError60: this.net.predictionError60?.toFixed(1) || '‚Äî',
            intercept: this.predictedIntercept ? 
                `x:${this.predictedIntercept.x.toFixed(0)},y:${this.predictedIntercept.y.toFixed(0)}` : '‚Äî',
            walls: this.world?._wallConfig ? `${this.world._wallConfig.generated} internal` : '‚Äî',
            coverDist: this._wallDistance < 50 ? 'NEAR' : (this._wallDistance < 100 ? 'MED' : 'FAR')
        };
    }

    clone() {
        const agent = new Agent(this.id, this.x, this.y, this.color, this.seed + '_clone_' + Date.now(), this.weaponType, this.team);
        agent.net = this.net.clone(); agent.critic = this.critic.clone(); agent.policySelector = this.policySelector.clone();
        agent.health = this.health; agent.stats = { ...this.stats }; agent.lastMutationType = this.lastMutationType;
        agent.cumulativeReward = this.cumulativeReward; agent.wins = this.wins; agent.totalKills = this.totalKills;
        agent.deaths = this.deaths; agent.mutations = this.mutations; agent.generation = this.generation + 1;
        agent.permanent = {
            skills: { ...this.permanent.skills }, strategies: { ...this.permanent.strategies },
            preferences: { ...this.permanent.preferences }, muscleMemory: new Float32Array(this.permanent.muscleMemory),
            memory: {
                lastFoodPos: this.permanent.memory.lastFoodPos ? { ...this.permanent.memory.lastFoodPos } : null,
                lastFoodStep: this.permanent.memory.lastFoodStep || 0,
                visited: new Set(this.permanent.memory.visited),
                unvisited: this.permanent.memory.unvisited.map(p => ({ ...p }))
            }
        };
        agent.predictive = {
            shortTerm: { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] },
            patterns: { enemyMovement: null, foodSpawn: null, dangerZones: new Map() },
            predictions: { enemyPos: { x: 0, y: 0 }, foodPos: { x: 0, y: 0 }, collision: false, success: 0.5 },            confidence: this.predictive.confidence, predictionError: this.predictive.predictionError
        };
        agent.skillEmbedding = this.skillEmbedding.slice(); agent.attackCooldown = this.attackCooldown || 0;
        agent.socialMemory = {
            interactions: new Map(this.socialMemory.interactions), reputation: this.socialMemory.reputation,
            lastAggressor: this.socialMemory.lastAggressor, allies: [...this.socialMemory.allies],
            killerHistory: [...this.socialMemory.killerHistory]
        };
        agent.evolutionPoints = this.evolutionPoints; agent.statChoices = [...this.statChoices];
        agent._lastHitDealt = this._lastHitDealt; agent._knockbackVelocity = { ...this._knockbackVelocity };
        agent._stunTimer = this._stunTimer; agent._weaponEffectTimer = this._weaponEffectTimer;
        agent._heavyHit = this._heavyHit; agent._pierced = this._pierced; agent._pulseEffect = this._pulseEffect;
        agent._continuousKB = this._continuousKB; agent._forcedCombatTimer = this._forcedCombatTimer;
        agent._learnFromWinner = this._learnFromWinner; agent._lastKiller = this._lastKiller;
        agent._deathMode = this._deathMode; agent._lastAttackDir = this._lastAttackDir;
        agent._recentArcExposure = this._recentArcExposure ? [...this._recentArcExposure] : [];
        agent._inEnemyArc = this._inEnemyArc;
        agent._lastThreatAssessment = this._lastThreatAssessment ? { ...this._lastThreatAssessment } : null;
        agent._totalDamageDealt = this._totalDamageDealt; agent._totalAttacks = this._totalAttacks;
        agent._successfulHits = this._successfulHits; agent._tacticalHits = this._tacticalHits;
        agent._frontalHits = this._frontalHits;
        agent.facingAngle = this.facingAngle; agent.velocity = { ...this.velocity };
        agent.decisionCommitment = Utils.deepClone(this.decisionCommitment);
        agent.actionState = { ...this.actionState };
        agent.world = this.world;
        agent.mentalMap = {
            enemies: new Map(this.mentalMap.enemies),
            lastUpdate: this.mentalMap.lastUpdate,
            targetPriority: this.mentalMap.targetPriority ? { ...this.mentalMap.targetPriority } : null
        };
        agent.assignedTargetId = this.assignedTargetId;
        agent.assignedRole = this.assignedRole;
        agent.explorationTarget = this.explorationTarget ? {...this.explorationTarget} : null;
        agent._combatTimer = this._combatTimer;
        agent.predictedIntercept = this.predictedIntercept ? {...this.predictedIntercept} : null;
        agent._moveAngle = this._moveAngle;
        agent._wasAttackingLastFrame = this._wasAttackingLastFrame;
        agent._attackToggleTimer = this._attackToggleTimer;
        agent._targetDeathFrame = this._targetDeathFrame;
        agent._targetSwitchFrame = this._targetSwitchFrame;
        return agent;
    }

    toJSON() {
        return {
            id: this.id, seed: this.seed, x: this.x, y: this.y, team: this.team, health: this.health, stats: this.stats,
            lastMutationType: this.lastMutationType, cumulativeReward: this.cumulativeReward,
            wins: this.wins, totalKills: this.totalKills, deaths: this.deaths, mutations: this.mutations,
            generation: this.generation, weaponType: this.weaponType, net: this.net.toJSON(),
            critic: this.critic.toJSON(), policySelector: this.policySelector.toJSON(),            permanent: {
                skills: this.permanent.skills, strategies: this.permanent.strategies,
                preferences: this.permanent.preferences, muscleMemory: Array.from(this.permanent.muscleMemory),
                memory: {
                    lastFoodPos: this.permanent.memory.lastFoodPos, lastFoodStep: this.permanent.memory.lastFoodStep,
                    visited: Array.from(this.permanent.memory.visited).slice(0, 100),
                    unvisited: this.permanent.memory.unvisited.slice(0, 30)
                }
            },
            predictive: { confidence: this.predictive.confidence, predictionError: this.predictive.predictionError },
            skillEmbedding: this.skillEmbedding.slice(),
            strategyMemory: { winningStrategies: this.strategyMemory.winningStrategies.slice(0, 5), fightHistory: this.strategyMemory.fightHistory },
            trainingStats: this.net._stats,
            socialMemory: {
                interactions: Array.from(this.socialMemory.interactions.entries()).map(([k, v]) => [k, { ...v }]),
                reputation: this.socialMemory.reputation, lastAggressor: this.socialMemory.lastAggressor,
                allies: [...this.socialMemory.allies], killerHistory: this.socialMemory.killerHistory
            },
            evolutionPoints: this.evolutionPoints, statChoices: [...this.statChoices],
            _lastHitDealt: this._lastHitDealt, _knockbackVelocity: this._knockbackVelocity,
            _stunTimer: this._stunTimer, _forcedCombatTimer: this._forcedCombatTimer,
            _learnFromWinner: this._learnFromWinner, _lastKiller: this._lastKiller,
            _deathMode: this._deathMode, _lastAttackDir: this._lastAttackDir,
            _recentArcExposure: this._recentArcExposure, _inEnemyArc: this._inEnemyArc,
            _lastThreatAssessment: this._lastThreatAssessment, _totalDamageDealt: this._totalDamageDealt,
            _totalAttacks: this._totalAttacks, _successfulHits: this._successfulHits,
            _tacticalHits: this._tacticalHits, _frontalHits: this._frontalHits,
            facingAngle: this.facingAngle, velocity: this.velocity,
            _angleToEnemy: this._angleToEnemy, _wallDistance: this._wallDistance,
            _isFacingEnemy: this._isFacingEnemy, _attackValid: this._attackValid,
            _exposure: this._exposure, _inCombatRange: this._inCombatRange,
            decisionCommitment: Utils.deepClone(this.decisionCommitment),
            actionState: { ...this.actionState },
            mentalMap: {
                enemies: Array.from(this.mentalMap.enemies.entries()).map(([k,v]) => [k, {...v}]),
                lastUpdate: this.mentalMap.lastUpdate,
                targetPriority: this.mentalMap.targetPriority ? {...this.mentalMap.targetPriority} : null
            },
            assignedTargetId: this.assignedTargetId,
            assignedRole: this.assignedRole,
            explorationTarget: this.explorationTarget,
            _combatTimer: this._combatTimer,
            predictedIntercept: this.predictedIntercept,
            _moveAngle: this._moveAngle,
            _wasAttackingLastFrame: this._wasAttackingLastFrame,
            _attackToggleTimer: this._attackToggleTimer,
            _targetDeathFrame: this._targetDeathFrame,
            _targetSwitchFrame: this._targetSwitchFrame
        };
    }
    static fromJSON(data, color) {
        const team = data.team || (data.id?.startsWith('red') ? 'red' : 'blue');
        const agent = new Agent(data.id, data.x, data.y, color, data.seed, data.weaponType || 'hammer', team);
        agent.net = Cortex2Brain.fromJSON(data.net);
        if (data.critic) agent.critic = CriticNetwork.fromJSON(data.critic);
        if (data.policySelector) agent.policySelector = PolicySelector.fromJSON(data.policySelector);
        agent.health = data.health ?? 100;
        agent.stats = data.stats || { maxHealth: 100, damage: 3, fireRate: 15, dodgeChance: 0.0 };
        agent.lastMutationType = data.lastMutationType || null;
        agent.cumulativeReward = data.cumulativeReward ?? 0;
        agent.wins = data.wins ?? 0; agent.totalKills = data.totalKills ?? 0;
        agent.deaths = data.deaths ?? 0; agent.mutations = data.mutations ?? 0;
        agent.generation = data.generation ?? 1;
        if (data.permanent) {
            agent.permanent.skills = { ...(data.permanent.skills || agent.permanent.skills) };
            agent.permanent.strategies = { ...(data.permanent.strategies || agent.permanent.strategies) };
            agent.permanent.preferences = { ...(data.permanent.preferences || agent.permanent.preferences) };
            if (data.permanent.muscleMemory) agent.permanent.muscleMemory = new Float32Array(data.permanent.muscleMemory);
            if (data.permanent.memory) {
                agent.permanent.memory.lastFoodPos = data.permanent.memory.lastFoodPos;
                agent.permanent.memory.lastFoodStep = data.permanent.memory.lastFoodStep || 0;
                agent.permanent.memory.visited = new Set(data.permanent.memory.visited || []);
                agent.permanent.memory.unvisited = data.permanent.memory.unvisited || [];
            }
        }
        if (data.strategyMemory) {
            agent.strategyMemory.winningStrategies = data.strategyMemory.winningStrategies || [];
            agent.strategyMemory.fightHistory = data.strategyMemory.fightHistory || {};
        }
        if (data.predictive) {
            agent.predictive.confidence = data.predictive.confidence ?? 0.5;
            agent.predictive.predictionError = data.predictive.predictionError ?? 0;
        }
        if (data.skillEmbedding) agent.skillEmbedding = data.skillEmbedding.slice();
        if (data.trainingStats) agent.net._stats = { ...data.trainingStats };
        if (data.socialMemory) {
            agent.socialMemory.interactions = new Map(data.socialMemory.interactions || []);
            agent.socialMemory.reputation = data.socialMemory.reputation ?? 0;
            agent.socialMemory.lastAggressor = data.socialMemory.lastAggressor || null;
            agent.socialMemory.allies = data.socialMemory.allies || [];
            agent.socialMemory.killerHistory = data.socialMemory.killerHistory || [];
        }
        if (data.evolutionPoints !== undefined) agent.evolutionPoints = data.evolutionPoints;
        if (data.statChoices) agent.statChoices = [...data.statChoices];
        if (data._lastHitDealt !== undefined) agent._lastHitDealt = data._lastHitDealt;
        if (data._knockbackVelocity) agent._knockbackVelocity = { ...data._knockbackVelocity };
        if (data._stunTimer !== undefined) agent._stunTimer = data._stunTimer;
        if (data._forcedCombatTimer !== undefined) agent._forcedCombatTimer = data._forcedCombatTimer;
        if (data._learnFromWinner !== undefined) agent._learnFromWinner = data._learnFromWinner;        if (data._lastKiller) agent._lastKiller = data._lastKiller;
        if (data._deathMode) agent._deathMode = data._deathMode;
        if (data._lastAttackDir !== undefined) agent._lastAttackDir = data._lastAttackDir;
        if (data._recentArcExposure) agent._recentArcExposure = [...data._recentArcExposure];
        if (data._inEnemyArc !== undefined) agent._inEnemyArc = data._inEnemyArc;
        if (data._lastThreatAssessment) agent._lastThreatAssessment = { ...data._lastThreatAssessment };
        if (data._totalDamageDealt !== undefined) agent._totalDamageDealt = data._totalDamageDealt;
        if (data._totalAttacks !== undefined) agent._totalAttacks = data._totalAttacks;
        if (data._successfulHits !== undefined) agent._successfulHits = data._successfulHits;
        if (data._tacticalHits !== undefined) agent._tacticalHits = data._tacticalHits;
        if (data._frontalHits !== undefined) agent._frontalHits = data._frontalHits;
        if (data.facingAngle !== undefined) agent.facingAngle = data.facingAngle;
        if (data.velocity) agent.velocity = { ...data.velocity };
        if (data._angleToEnemy !== undefined) agent._angleToEnemy = data._angleToEnemy;
        if (data._wallDistance !== undefined) agent._wallDistance = data._wallDistance;
        if (data._isFacingEnemy !== undefined) agent._isFacingEnemy = data._isFacingEnemy;
        if (data._attackValid !== undefined) agent._attackValid = data._attackValid;
        if (data._exposure) agent._exposure = { ...data._exposure };
        if (data._inCombatRange !== undefined) agent._inCombatRange = data._inCombatRange;
        if (data.decisionCommitment) agent.decisionCommitment = Utils.deepClone(data.decisionCommitment);
        if (data.actionState) agent.actionState = { ...data.actionState };
        if (data.mentalMap) {
            agent.mentalMap.enemies = new Map(data.mentalMap.enemies?.map(([k,v]) => [k, {...v}]) || []);
            agent.mentalMap.lastUpdate = data.mentalMap.lastUpdate || 0;
            agent.mentalMap.targetPriority = data.mentalMap.targetPriority ? {...data.mentalMap.targetPriority} : null;
        }
        if (data.assignedTargetId !== undefined) agent.assignedTargetId = data.assignedTargetId;
        if (data.assignedRole) agent.assignedRole = data.assignedRole;
        if (data.explorationTarget) agent.explorationTarget = {...data.explorationTarget};
        if (data._combatTimer !== undefined) agent._combatTimer = data._combatTimer;
        if (data.predictedIntercept) agent.predictedIntercept = {...data.predictedIntercept};
        if (data._moveAngle !== undefined) agent._moveAngle = data._moveAngle;
        if (data._wasAttackingLastFrame !== undefined) agent._wasAttackingLastFrame = data._wasAttackingLastFrame;
        if (data._attackToggleTimer !== undefined) agent._attackToggleTimer = data._attackToggleTimer;
        if (data._targetDeathFrame !== undefined) agent._targetDeathFrame = data._targetDeathFrame;
        if (data._targetSwitchFrame !== undefined) agent._targetSwitchFrame = data._targetSwitchFrame;
        return agent;
    }
}

// ============================================================================
// SECTION 9: WORLD CLASS (10/10 AUDITED)
// ============================================================================

class World {
    constructor(width, height) {
        this.logicalWidth = width;
        this.logicalHeight = height;
        this.step = 0;
        this.episode = 0;        this.totalFights = 0;
        this.walls = [];
        this.enemies = [];
        this.projectiles = [];
        this.healthPacks = [];
        this._nextPackSpawn = 600;
        this._packSpawnInterval = 600;
        this._wallConfig = null;
        this._validatedSpawns = null;
    }

    reset(wallSeed = null) {
        this.step = 0;
        
        const wallConfig = {
            count: arenaConfig.wallCount || 3,
            length: arenaConfig.wallLength || 120,
            seed: wallSeed || arenaConfig.seed + '_EP' + this.episode
        };
        
        if (arenaConfig.enableWalls !== false) {
            const result = WallGenerator.generateRandomWalls(
                this.logicalWidth,
                this.logicalHeight,
                wallConfig.count,
                wallConfig.length,
                wallConfig.seed
            );
            this.walls = result.walls;
            this._wallConfig = { ...wallConfig, generated: result.generated };
            
            const spawnPoints = {
                blue: [{x:120,y:180}, {x:120,y:400}, {x:180,y:290}, {x:220,y:220}],
                red:  [{x:730,y:180}, {x:730,y:400}, {x:670,y:290}, {x:630,y:220}]
            };
            
            for (const team of ['blue', 'red']) {
                for (let i = 0; i < spawnPoints[team].length; i++) {
                    let pos = spawnPoints[team][i];
                    let attempts = 0;
                    while (this.walls.some(w => 
                        w instanceof Wall && w.type !== 'border' && w.distanceToPoint(pos.x, pos.y) < 40
                    ) && attempts < 10) {
                        pos = {
                            x: pos.x + Utils.rand(-15, 15),
                            y: pos.y + Utils.rand(-15, 15)
                        };
                        attempts++;
                    }
                    spawnPoints[team][i] = pos;                }
            }
            this._validatedSpawns = spawnPoints;
            
            Logger.log(`üß± Walls: ${this._wallConfig.generated}/${this._wallConfig.count} internal + 4 border`, 'info');
        } else {
            this.walls = [
                new Wall(0, 0, this.logicalWidth, 0, 'border'),
                new Wall(this.logicalWidth, 0, this.logicalWidth, this.logicalHeight, 'border'),
                new Wall(this.logicalWidth, this.logicalHeight, 0, this.logicalHeight, 'border'),
                new Wall(0, this.logicalHeight, 0, 0, 'border')
            ];
            this._wallConfig = { count: 0, length: 0, generated: 0, ...wallConfig };
            this._validatedSpawns = {
                blue: [{x:120,y:180}, {x:120,y:400}, {x:180,y:290}, {x:220,y:220}, {x:220,y:360}, {x:170,y:260}, {x:170,y:320}, {x:140,y:290}],
                red:  [{x:730,y:180}, {x:730,y:400}, {x:670,y:290}, {x:630,y:220}, {x:630,y:360}, {x:680,y:260}, {x:680,y:320}, {x:710,y:290}]
            };
        }
        
        this.projectiles = [];
        this.healthPacks = [];
        this._nextPackSpawn = 600;
    }

    _spawnHealthPack() {
        const margin = 50;
        const maxAttempts = 50;
        
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const x = margin + Utils.rand(0, this.logicalWidth - margin * 2);
            const y = margin + Utils.rand(0, this.logicalHeight - margin * 2);
            
            const tooCloseToWall = this.walls.some(w => w instanceof Wall ? w.distanceToPoint(x, y) < 40 : Utils.dist({x, y}, w) < 40);
            if (tooCloseToWall) continue;
            
            const tooCloseToAgent = this.enemies.some(a => 
                a?.alive && Utils.dist({x, y}, a) < 80
            );
            if (tooCloseToAgent) continue;
            
            const tooCloseToPack = this.healthPacks.some(p => 
                !p.collected && Utils.dist({x, y}, p) < 60
            );
            if (tooCloseToPack) continue;
            
            this.healthPacks.push(new HealthPack(x, y));
            Logger.log(`üß™ Health pack spawned at (${Math.round(x)}, ${Math.round(y)})`, 'info');
            return;
        }
        Logger.log('‚ö†Ô∏è Could not find valid health pack spawn location', 'warn');    }

    spawnAgents(countPerTeam = 2, blueWeapon = 'hammer', redWeapon = 'hammer') {
        this.enemies = [];
        const colors = { blue: '#00d4ff', red: '#ff5577' };
        const weapons = { blue: blueWeapon, red: redWeapon };
        
        const spawnPoints = this._validatedSpawns || {
            blue: [{x:120,y:180}, {x:120,y:400}, {x:180,y:290}, {x:220,y:220}, {x:220,y:360}, {x:170,y:260}, {x:170,y:320}, {x:140,y:290}],
            red:  [{x:730,y:180}, {x:730,y:400}, {x:670,y:290}, {x:630,y:220}, {x:630,y:360}, {x:680,y:260}, {x:680,y:320}, {x:710,y:290}]
        };
        
        let agentId = 0;
        for (const team of ['blue', 'red']) {
            for (let i = 0; i < countPerTeam; i++) {
                const uniqueSeed = `${arenaConfig.seed}_${team.toUpperCase()}_A${i}_${agentId}`;
                const pos = spawnPoints[team][i % spawnPoints[team].length];
                const agent = new Agent(
                    `${team}_${i}`,
                    pos.x + Utils.rand(-20, 20),
                    pos.y + Utils.rand(-20, 20),
                    colors[team],
                    uniqueSeed,
                    weapons[team],
                    team
                );
                this.enemies.push(agent);
                agentId++;
            }
        }
        Logger.log(`[World] Spawned ${this.enemies.length} agents (${countPerTeam} per team)`, 'success');
    }

    update(dt) {
        this.step++;
        if (!this.enemies?.length || this.enemies.length < 2) {
            console.error('World.update: Invalid agents array');
            return { episode: this.episode, totalFights: this.totalFights };
        }
        
        const aliveAgents = this.enemies
            .filter(a => a?.alive)
            .sort((a, b) => a.id.localeCompare(b.id));
        
        if (arenaConfig.enableHealthPacks !== false) {
            this._nextPackSpawn -= dt;
            if (this._nextPackSpawn <= 0 && this.healthPacks.length < 3) {
                this._spawnHealthPack();
                this._nextPackSpawn = this._packSpawnInterval;
            }        }
        
        for (const agent of aliveAgents) {
            agent.world = this;
            agent._updateMentalMap(this);
        }
        
        for (const agent of aliveAgents) {
            if (agent._heavyHit > 0) agent._heavyHit--;
            if (agent._pierced > 0) agent._pierced--;
            if (agent._pulseEffect > 0) agent._pulseEffect--;
            if (agent._continuousKB > 0) agent._continuousKB = Math.max(0, agent._continuousKB - 0.03);
            const enemies = this.enemies.filter(e => e && e.id !== agent.id && e.alive && e.team !== agent.team);
            if (enemies.length > 0) {
                const enemy = enemies[0], distance = Utils.dist(agent, enemy);
                if (distance < 150) {
                    agent.enemyPredictor.recordMove(agent.lastDecision?.behaviors || {}, distance, enemy.health / enemy.stats.maxHealth, agent.lastDecision?.behaviors?.aggression || 0.5);
                    if (distance < 100) agent.decideCombatAction(enemy, this);
                }
            }
            const decision = agent.decide(this);
            agent.move(decision, this.walls, dt, aliveAgents);
            agent.attackCooldown = Math.max(0, (agent.attackCooldown || 0) - 1);
            
            if (arenaConfig.enableFighting) {
                const opponents = this.enemies.filter(e => e && e.id !== agent.id && e.alive && e.team !== agent.team);
                if (opponents.length > 0) {
                    const sortedOpponents = opponents.sort((a, b) => Utils.dist(agent, a) - Utils.dist(agent, b));
                    const enemy = sortedOpponents[0];
                    const dist = Utils.dist(agent, enemy);
                    const range = agent.attackRange || Agent.ATTACK_RANGE;
                    let attacked = false;
                    if (dist <= range && (agent.attackCooldown || 0) <= 0) {
                        if (!agent.isPointInWeaponArc(enemy)) {
                            agent.attackCooldown = Math.floor(agent.stats.fireRate * 0.4);
                            attacked = true;
                            agent._combatEvents.push({ type: 'hit_missed' });
                        } else {
                            this.totalFights++;
                            const aggression = agent.lastDecision?.behaviors?.aggression || 0.5, skill = agent.permanent?.skills?.combat || 0.3, baseDmg = agent.stats.damage;
                            const directionalMult = enemy.calculateDirectionalDamageMultiplier(agent);
                            const damage = Math.floor(Utils.clamp(baseDmg * (0.8 + aggression * 0.4) * (0.7 + skill * 0.6) * directionalMult, 1, 15));
                            const dodgeRoll = Math.random();
                            if (dodgeRoll < enemy.stats.dodgeChance) {
                                agent._combatEvents.push({ type: 'hit_missed' });
                            } else {
                                enemy.health -= damage;
                                enemy._lastHitReceived = damage;
                                agent._lastHitDealt = damage;
                                agent._totalAttacks++;                                agent._totalDamageDealt += damage;
                                agent._successfulHits++;
                                if (directionalMult >= 1.5) agent._tacticalHits++;
                                else if (directionalMult <= 0.7) agent._frontalHits++;
                                agent._lastAttackDir = Math.atan2(enemy.y - agent.y, enemy.x - agent.x);
                                agent._applyKnockback(enemy, aggression, agent.weapon);
                                agent._combatEvents.push({ type: 'hit_dealt', damage });
                                enemy._combatEvents.push({ type: 'damage_received', damage, attacker: agent.id });
                            }
                            agent.attackCooldown = agent.stats.fireRate;
                            attacked = true;
                            if (enemy.health <= 0) {
                                enemy.health = 0;
                                enemy.alive = false;
                                agent._combatEvents.push({ type: 'enemy_defeated', target: enemy.id });
                                enemy._combatEvents.push({ type: 'killed_by', killer: agent.id });
                            }
                        }
                    } else if (arenaConfig.enableRanged && (agent.attackCooldown || 0) <= 0) {
                        if (agent.weapon.type === 'ranged') {
                            const aggr = agent.lastDecision?.behaviors?.aggression || 0.4;
                            if (aggr > 0.3 && dist > range && dist <= 200) {
                                const dir = Utils.normalize(enemy.x - agent.x, enemy.y - agent.y);
                                const speed = 10 + Math.random() * 4;
                                const dmg = Math.floor(Utils.clamp(agent.stats.damage * 0.5 * (0.8 + aggr * 0.8), 1, 5));
                                const p = new Projectile(agent.x + dir.x * 12, agent.y + dir.y * 12, dir.x * speed, dir.y * speed, agent.id, dmg, 80);
                                this.projectiles.push(p);
                                agent.attackCooldown = agent.stats.fireRate + 5;
                                attacked = true;
                            }
                        }
                    }
                    if (attacked && agent.attackCooldown <= 0) {
                        agent.attackCooldown = agent.stats.fireRate;
                    }
                }
            }
            const reward = agent.calculateReward(this, decision);
            const nextInputs = agent.getInputs(this);
            const safeReward = isFinite(reward) ? reward : 0;
            if (nextInputs && nextInputs.length > 0) {
                const validInputs = nextInputs.every(v => isFinite(v));
                if (validInputs) {
                    agent.learn(safeReward, decision, nextInputs);
                }
            }
            
            if (arenaConfig.enableHealthPacks !== false) {
                for (const pack of this.healthPacks) {
                    if (pack.collected) continue;                    if (pack.isCollectedBy(agent)) {
                        const oldHealth = agent.health;
                        const newHealth = Math.min(agent.stats.maxHealth, agent.health + pack.healAmount);
                        const healed = newHealth - oldHealth;
                        
                        if (healed > 0) {
                            agent.health = newHealth;
                            pack.collected = true;
                            agent.cumulativeReward += healed * 0.5;
                            agent._combatEvents.push({ type: 'healed', amount: healed });
                            Logger.log(`üíö ${agent.id} healed +${healed} HP`, 'success');
                        }
                    }
                }
                this.healthPacks = this.healthPacks.filter(p => !p.collected && p.lifetime > 0);
            }
        }
        
        for (const p of this.projectiles) {
            if (!p?.alive) continue;
            p.update(dt);
            for (const w of this.walls) {
                const dist = w instanceof Wall ? w.distanceToPoint(p.x, p.y) : Utils.dist(p, w);
                if (dist < 14 + p.radius) { p.alive = false; break; }
            }
            if (!p.alive) continue;
            for (const e of this.enemies) {
                if (!e || !e.alive || e.id === p.owner) continue;
                if (Utils.dist(p, e) < 15) {
                    const dodgeRoll = Math.random();
                    if (dodgeRoll >= e.stats.dodgeChance) {
                        e.health -= p.damage;
                        e._lastHitReceived = p.damage;
                        e._combatEvents.push({ type: 'damage_received', damage: p.damage, attacker: p.owner });
                    }
                    p.alive = false;
                    if (e.health <= 0) {
                        e.health = 0; e.alive = false;
                        e._combatEvents.push({ type: 'killed_by', killer: p.owner });
                    }
                    break;
                }
            }
        }
        this.projectiles = this.projectiles.filter(p => p?.alive);
        
        for (const agent of aliveAgents) {
            agent._lastHitDealt = 0;
            agent._lastHitReceived = 0;
            agent._combatEvents = [];        }
        
        const blueAlive = this.enemies.filter(a => a?.alive && a.team === 'blue').length;
        const redAlive = this.enemies.filter(a => a?.alive && a.team === 'red').length;
        if (blueAlive === 0 || redAlive === 0) {
            const winner = blueAlive > 0 ? 'blue' : (redAlive > 0 ? 'red' : 'draw');
            this._endRound(winner);
        }
        return { episode: this.episode, totalFights: this.totalFights };
    }

    _endRound(winner) {
        this.episode++;
        Logger.log(`üèÜ –†–∞—É–Ω–¥ ${this.episode} –∑–∞–≤–µ—Ä—à–µ–Ω. –ü–æ–±–µ–¥–∞: ${winner.toUpperCase()}`, 'success');
        if (winner !== 'draw') {
            const winners = this.enemies.filter(a => a.team === winner);
            for (const agent of winners) {
                agent.wins++;
                agent.evolutionPoints = 2;
                agent.applyEvolutionPoints();
                agent.cumulativeReward += arenaConfig.EVOLUTION.WIN_BONUS;
                agent.net.updateDiagnostics({ kill: true });
                Logger.log(`üèÜ ${agent.id.toUpperCase()} Gen${agent.generation} wins! Total Wins: ${agent.wins}`, 'success');
            }
        }
        const losers = this.enemies.filter(a => a.team !== winner);
        for (const agent of losers) {
            agent.deaths++;
            agent._lastKiller = winner === 'blue' ? 'red_team' : 'blue_team';
            agent.net.updateDiagnostics({ death: true });
        }
        this._respawnAllAgents();
    }

    _respawnAllAgents() {
        const spawnPoints = this._validatedSpawns || {
            blue: [{x:120,y:180}, {x:120,y:400}, {x:180,y:290}, {x:220,y:220}],
            red:  [{x:730,y:180}, {x:730,y:400}, {x:670,y:290}, {x:630,y:220}]
        };
        for (const agent of this.enemies) {
            const pos = spawnPoints[agent.team][parseInt(agent.id.split('_')[1]) % spawnPoints[agent.team].length];
            agent.reset(pos.x, pos.y);
            agent.alive = true;
        }
        Logger.log(`üîÑ –í—Å–µ –∞–≥–µ–Ω—Ç—ã –≤–æ–∑—Ä–æ–∂–¥–µ–Ω—ã –¥–ª—è –Ω–æ–≤–æ–≥–æ —Ä–∞—É–Ω–¥–∞`, 'info');
    }

    draw(ctx, vision = false, trail = true) {
        if (!ctx) return;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);        const grad = ctx.createLinearGradient(0, 0, this.logicalWidth, this.logicalHeight);
        grad.addColorStop(0, '#0a0a15'); grad.addColorStop(1, '#1a1a2e');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, this.logicalWidth, this.logicalHeight);
        ctx.strokeStyle = 'rgba(50,50,90,0.25)'; ctx.lineWidth = 1;
        for (let x = 0; x < this.logicalWidth; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, this.logicalHeight); ctx.stroke(); }
        for (let y = 0; y < this.logicalHeight; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(this.logicalWidth, y); ctx.stroke(); }
        
        for (const w of this.walls) {
            if (w instanceof Wall) {
                w.draw(ctx);
            } else {
                ctx.fillStyle = '#4a4a7a';
                ctx.beginPath();
                ctx.arc(w.x, w.y, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#6a6a9a';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        for (const pr of this.projectiles || []) if (pr) pr.draw(ctx);
        
        for (const pack of this.healthPacks) {
            if (!pack.collected) pack.draw(ctx);
        }
        for (const a of this.enemies) if (a) a.draw(ctx, vision, trail);
        ctx.fillStyle = 'rgba(100,100,140,0.5)'; ctx.font = '10px monospace';
        ctx.fillText(`Step: ${this.step} | Ep: ${this.episode} | Fights: ${this.totalFights}`, 12, this.logicalHeight - 12);
    }
}

// ============================================================================
// SECTION 10: LOGGER
// ============================================================================

const Logger = Object.freeze({
    _escape: (str) => String(str).replace(/[&<>"']/g, m => ({ '&': '&', '<': '<', '>': '>', '"': '"', "'": '&#039;' }[m])),
    _truncate: (str, max = 180) => str.length > max ? str.slice(0, max) + '‚Ä¶' : str,
    log: (msg, type = 'info') => {
        const safeMsg = Logger._escape(Logger._truncate(msg));
        const safeType = ['info', 'success', 'warn', 'error', 'learning'].includes(type) ? type : 'info';
        const logEl = document.getElementById('eventLog');
        if (!logEl) { console.log(`[${safeType}] ${safeMsg}`); return; }
        const entry = document.createElement('div');
        entry.className = `log-entry ${safeType}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${safeMsg}`;
        logEl.insertBefore(entry, logEl.firstChild);
        while (logEl.children.length > 30) logEl.removeChild(logEl.lastChild);
        logEl.scrollTop = 0;    }
});

// ============================================================================
// SECTION 11: GAME ENGINE
// ============================================================================

class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        if (!this.canvas) { console.error('Canvas element not found'); return; }
        this.ctx = this.canvas.getContext('2d');
        if (!this.ctx) { console.error('Failed to get canvas context'); return; }
        this.logicalWidth = arenaConfig.ARCH.LOGICAL_WIDTH;
        this.logicalHeight = arenaConfig.ARCH.LOGICAL_HEIGHT;
        this.resize();
        this.world = new World(this.logicalWidth, this.logicalHeight);
        this.running = false; this.lastTime = 0; this.fps = 60;
        this.vision = false; this.debug = false; this.showMetrics = true;
        this.showMazeGrid = false;
        this.selectedAgent = null; this.rafId = null;
        this._onResize = this._onResize.bind(this);
        this._onClick = this._onClick.bind(this);
        this._onKey = this._onKey.bind(this);
        this.setupEvents();
        this.init();
    }

    resize() {
        const parent = this.canvas?.parentElement;
        if (!parent) return;
        this.canvas.width = parent.clientWidth;
        this.canvas.height = parent.clientHeight;
    }

    _onResize() { this.resize(); }
    setupEvents() {
        window.addEventListener('resize', this._onResize);
        const handlePointer = (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const clientX = e.touches?.[0]?.clientX ?? e.clientX;
            const clientY = e.touches?.[0]?.clientY ?? e.clientY;
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            this._onClick({ x, y });
        };
        this.canvas.addEventListener('click', handlePointer);
        this.canvas.addEventListener('touchend', handlePointer);
        this.canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
        document.addEventListener('keydown', this._onKey);
        this.canvas.setAttribute('tabindex', '0');
        this.canvas.setAttribute('role', 'application');
        this.canvas.setAttribute('aria-label', 'AI Arena simulation canvas');
        
        document.getElementById('btnStart').onclick = () => this.toggle();
        document.getElementById('btnReset').onclick = () => this.reset();
        document.getElementById('btnSave').onclick = () => this.save();
        document.getElementById('btnLoad').onclick = () => this.load();
        document.getElementById('btnExport').onclick = () => this.exportWeights();
        document.getElementById('btnDebug').onclick = () => this.toggleDebug();
        document.getElementById('btnVision').onclick = () => { this.vision = !this.vision; this.updateBtns(); };
        document.getElementById('btnApplyWeapons').onclick = () => this.applyWeapons();
        document.getElementById('btnRandomWeapons').onclick = () => this.randomWeapons();
        document.getElementById('btnRegenerateWalls').onclick = () => this.regenerateWalls();
        document.getElementById('btnShowGrid').onclick = function() {
            this.classList.toggle('active');
            window.arenaGame.showMazeGrid = this.classList.contains('active');
        };
        document.getElementById('fileImport').onchange = (e) => this.importWeights(e);
        
        const bindSlider = (id, configKey, displayId, callback) => {
            const slider = document.getElementById(id);
            const display = document.getElementById(displayId);
            if (!slider || !display) return;
            slider.oninput = (e) => {
                const value = parseFloat(e.target.value);
                if (!isFinite(value)) return;
                arenaConfig[configKey] = value;
                display.textContent = value.toFixed(3);
                if (typeof callback === 'function') {
                    try { callback.call(this, value); } catch (err) { console.error(err); }
                }
            };        };
        
        bindSlider('learningRate', 'learningRate', 'learningRateValue', (v) => {
            if (this.world?.enemies) this.world.enemies.forEach(a => { if (a?.net) a.net.lr = v; });
        });
        bindSlider('lambda', 'lambda', 'lambdaValue', (v) => {
            if (this.world?.enemies) this.world.enemies.forEach(a => { if (a?.net) a.net.lambda = v; });
        });
        bindSlider('mutationRate', 'mutationRate', 'mutationRateValue');
        bindSlider('agentSpeed', 'agentSpeed', 'agentSpeedValue', (v) => {
            if (this.world?.enemies) this.world.enemies.forEach(a => { if (a) a.speed = v; });
        });
        bindSlider('agentCount', 'agentCount', 'agentCountValue');
        bindSlider('viewRadius', 'viewRadius', 'viewRadiusValue');
        bindSlider('wallCount', 'wallCount', 'wallCountValue', (v) => {
            arenaConfig.wallCount = Math.floor(v);
        });
        bindSlider('wallLength', 'wallLength', 'wallLengthValue', (v) => {
            arenaConfig.wallLength = Math.floor(v);
        });
        
        const bindToggle = (id, configKey) => {
            const toggle = document.getElementById(id);
            if (toggle) {
                toggle.onchange = (e) => { arenaConfig[configKey] = e.target.checked; };
            }
        };
        
        bindToggle('enableTraining', 'enableTraining');
        bindToggle('enableEvolution', 'enableEvolution');
        bindToggle('enableFighting', 'enableFighting');
        bindToggle('enableRanged', 'enableRanged');
        bindToggle('enableWeightInheritance', 'enableWeightInheritance');
        bindToggle('enableTactical', 'enableTactical');
        bindToggle('enableHebbian', 'enableHebbian');
        bindToggle('enableConsolidation', 'enableConsolidation');
        bindToggle('enableHealthPacks', 'enableHealthPacks');
        bindToggle('enableLowHealthHint', 'enableLowHealthHint');
        bindToggle('enableWalls', 'enableWalls');
    }

    _onKey(e) {
        if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
        switch (e.key) {
            case ' ': e.preventDefault(); this.toggle(); break;
            case '1': this.selectedAgent = this.world?.enemies?.[0]; this.updateDebugPanel(); break;
            case '2': this.selectedAgent = this.world?.enemies?.[1]; this.updateDebugPanel(); break;
            case 'Tab': e.preventDefault(); const focusable = document.querySelectorAll('button, input, [tabindex="0"]'), idx = Array.from(focusable).indexOf(document.activeElement); focusable[(idx + 1) % focusable.length]?.focus(); break;
            case 'Escape': if (this.debug) { this.debug = false; this.updateDebugPanel(); } break;
            case 'w': if (this.debug) this.regenerateWalls(); break;            case 'h': arenaConfig.enableHealthPacks = !arenaConfig.enableHealthPacks; Logger.log(`üß™ Health packs: ${arenaConfig.enableHealthPacks ? 'ON' : 'OFF'}`, 'info'); break;
            case 'v': this.vision = !this.vision; this.updateBtns(); break;
        }
    }
    
    _onClick({ x, y }) {
        if (!this.debug) return;
        const lx = x / (this.canvas.width / this.logicalWidth), ly = y / (this.canvas.height / this.logicalHeight);
        let nearest = null, minD = 25;
        for (const a of this.world?.enemies || []) {
            if (!a) continue;
            const d = Math.hypot(a.x - lx, a.y - ly);
            if (d < minD) { minD = d; nearest = a; }
        }
        this.selectedAgent = nearest;
        if (nearest) Logger.log(`üîç –í—ã–±—Ä–∞–Ω –∞–≥–µ–Ω—Ç ${nearest.id}`, 'info');
        this.updateDebugPanel();
    }

    init() {
        this.world.reset();
        const count = parseInt(document.getElementById('agentCount').value);
        const blueWeapon = document.getElementById('blueWeaponSelect').value;
        const redWeapon = document.getElementById('redWeaponSelect').value;
        this.world.spawnAgents(count, blueWeapon, redWeapon);
        this.updateAgentList();
        this.updateStats();
        Logger.log('üöÄ AI Arena v6.0.9 Professional initialized', 'success');
        Logger.log(`üìê Map: ${this.logicalWidth}√ó${this.logicalHeight} | Walls: ${this.world._wallConfig?.generated || 0}`, 'info');
    }

    toggle() {
        this.running = !this.running;
        const btn = document.getElementById('btnStart');
        btn.textContent = this.running ? '‚è∏ –ü–∞—É–∑–∞' : '‚ñ∂ –°—Ç–∞—Ä—Ç';
        btn.className = this.running ? 'btn-danger' : 'btn-primary';
        if (this.running) { this.lastTime = performance.now(); this.loop(); }
    }

    reset() {
        this.running = false;
        document.getElementById('btnStart').textContent = '‚ñ∂ –°—Ç–∞—Ä—Ç';
        document.getElementById('btnStart').className = 'btn-primary';
        this.world = new World(this.logicalWidth, this.logicalHeight);
        this.world.reset();
        const count = parseInt(document.getElementById('agentCount').value);
        const blueWeapon = document.getElementById('blueWeaponSelect').value;
        const redWeapon = document.getElementById('redWeaponSelect').value;
        this.world.spawnAgents(count, blueWeapon, redWeapon);
        this.updateAgentList();        this.updateStats();
        Logger.log('üîÑ Reset', 'warn');
    }
    
    regenerateWalls() {
        if (this.world) {
            const seed = arenaConfig.seed + '_MANUAL_' + Date.now();
            this.world.reset(seed);
            const count = parseInt(document.getElementById('agentCount').value);
            const blueWeapon = document.getElementById('blueWeaponSelect').value;
            const redWeapon = document.getElementById('redWeaponSelect').value;
            this.world.spawnAgents(count, blueWeapon, redWeapon);
            Logger.log(`üß± Walls regenerated: ${arenaConfig.wallCount} walls`, 'info');
            this.updateStats();
        }
    }

    loop() {
        if (!this.running) return;
        const now = performance.now();
        const deltaTime = now - this.lastTime;
        if (deltaTime > 250) { this.lastTime = now; this.rafId = requestAnimationFrame(() => this.loop()); return; }
        const dt = Math.min(deltaTime / 16.67, 2);
        this.fps = Math.round(1000 / (deltaTime + 0.001));
        this.lastTime = now;
        document.getElementById('fpsCounter').textContent = `FPS: ${this.fps}`;
        this.world.update(dt);
        this.world.draw(this.ctx, this.vision);
        this.updateStats();
        this.updateMetrics();
        this.updateAgentList();
        this.updateLowHealthHint();
        if (this.debug) this.updateDebugPanel();
        this.rafId = requestAnimationFrame(() => this.loop());
    }

    updateAgentList() {
        const container = document.getElementById('agentList');
        if (!container || !this.world?.enemies) return;
        container.innerHTML = this.world.enemies.map(agent => `
            <article class="agent-card ${agent.team}" style="border-left-color: ${agent.color}">
                <header class="agent-header">
                    <span style="color:${agent.color}">‚óè</span>
                    <span>${agent.id.toUpperCase()}</span>
                    <span style="margin-left:auto; font-size:0.5rem; opacity:0.7">${agent.team.toUpperCase()}</span>
                </header>
                <div class="health-bar"><div class="health-fill" style="width:${(agent.health/agent.stats.maxHealth)*100}%"></div></div>
                <div class="agent-stats"><span>HP: <b>${Math.round(agent.health)}</b></span><span>Wins: <b>${agent.wins}</b></span></div>
                <div class="weapon-badge">${agent.weapon.icon} ${agent.weapon.name}</div>
            </article>        `).join('');
    }

    updateStats(state = null) {
        if (!state) state = { episode: this.world.episode, totalFights: this.world.totalFights };
        document.getElementById('episodeStat').textContent = state.episode;
        document.getElementById('stepStat').textContent = this.world.step;
        document.getElementById('totalFightsStat').textContent = state.totalFights;
        document.getElementById('obstaclesStat').textContent = this.world.walls.filter(w => w instanceof Wall && w.type !== 'border').length;
        document.getElementById('episodeProgress').style.width = `${(state.episode % 10) * 10}%`;
    }

    updateMetrics() {
        if (!this.world?.enemies?.length) return;
        const agents = this.world.enemies.filter(a => a && a.alive);
        if (!agents.length) return;
        const avgTD = agents.reduce((s, a) => s + (a.net.getStats().tdErrorHistory?.reduce((x,y)=>x+y,0)/Math.max(1,a.net.getStats().tdErrorHistory?.length || 1) || 0), 0) / agents.length;
        const avgWin = agents.reduce((s, a) => s + (a.wins / Math.max(1, a.wins + a.deaths)), 0) / agents.length;
        const avgDmg = agents.reduce((s, a) => s + (a._totalDamageDealt / Math.max(1, a._totalAttacks)), 0) / agents.length;
        const avgAcc = agents.reduce((s, a) => s + (a._successfulHits / Math.max(1, a._totalAttacks)), 0) / agents.length;
        document.getElementById('metricTDError').textContent = avgTD.toFixed(4);
        document.getElementById('metricWinRate').textContent = avgWin.toFixed(2);
        document.getElementById('metricDamage').textContent = avgDmg.toFixed(2);
        document.getElementById('metricAccuracy').textContent = avgAcc.toFixed(2);
    }

    updateLowHealthHint() {
        const hintPanel = document.getElementById('lowHealthHint');
        if (hintPanel && arenaConfig.enableLowHealthHint) {
            const anyLowHealth = this.world?.enemies?.some(a => 
                a?.alive && a.health < a.stats.maxHealth * 0.5
            );
            hintPanel.style.display = anyLowHealth ? 'block' : 'none';
        }
    }

    updateDebugPanel() {
        const panel = document.getElementById('debugPanel');
        const isActive = this.debug && this.selectedAgent;
        panel.classList.toggle('active', isActive);
        if (!isActive || !this.selectedAgent) return;
        const info = this.selectedAgent.getDebugInfo();
        document.getElementById('debugGrid').innerHTML = Object.entries(info).map(([k, v]) => `<div class="debug-item"><span class="debug-label">${k}</span><span class="debug-value">${v}</span></div>`).join('');
    }

    toggleDebug() {
        this.debug = !this.debug;
        document.getElementById('btnDebug').classList.toggle('active', this.debug);
        this.updateDebugPanel();
    }
    updateBtns() {
        document.getElementById('btnVision').classList.toggle('active', this.vision);
    }
    
    save() {
        const data = { 
            version: '6.0.9-PROFESSIONAL', 
            timestamp: Date.now(), 
            config: { 
                agentCount: document.getElementById('agentCount').value, 
                learningRate: arenaConfig.learningRate, 
                agentSpeed: arenaConfig.agentSpeed, 
                viewRadius: arenaConfig.viewRadius,
                wallCount: arenaConfig.wallCount,
                wallLength: arenaConfig.wallLength
            }, 
            world: { 
                episode: this.world.episode, 
                step: this.world.step, 
                totalFights: this.world.totalFights, 
                walls: this.world.walls.map(w => w instanceof Wall ? w.toJSON() : w),
                wallConfig: this.world._wallConfig,
                validatedSpawns: this.world._validatedSpawns
            }, 
            agents: this.world.enemies.map(a => a.toJSON()),
            healthPacks: this.world.healthPacks.map(p => p.toJSON())
        };
        localStorage.setItem('aiArenaV6Pro', JSON.stringify(data));
        Logger.log('üíæ Saved', 'success');
    }

    load() {
        const raw = localStorage.getItem('aiArenaV6Pro');
        if (!raw) { Logger.log('‚ùå No save', 'error'); return; }
        const data = JSON.parse(raw);
        document.getElementById('agentCount').value = data.config?.agentCount || 2;
        arenaConfig.learningRate = data.config?.learningRate || 0.015;
        arenaConfig.agentSpeed = data.config?.agentSpeed || 10;
        arenaConfig.viewRadius = data.config?.viewRadius || 250;
        arenaConfig.wallCount = data.config?.wallCount || 3;
        arenaConfig.wallLength = data.config?.wallLength || 120;
        document.getElementById('learningRateValue').textContent = arenaConfig.learningRate.toFixed(3);
        document.getElementById('agentSpeedValue').textContent = arenaConfig.agentSpeed.toFixed(0);
        document.getElementById('viewRadiusValue').textContent = arenaConfig.viewRadius.toFixed(0);
        document.getElementById('wallCountValue').textContent = arenaConfig.wallCount;
        document.getElementById('wallLengthValue').textContent = arenaConfig.wallLength;
        this.world.episode = data.world?.episode || 0;
        this.world.step = data.world?.step || 0;
        this.world.totalFights = data.world?.totalFights || 0;        this.world.walls = (data.world?.walls || []).map(w => Wall.fromJSON(w));
        this.world._wallConfig = data.world?.wallConfig || null;
        this.world._validatedSpawns = data.world?.validatedSpawns || null;
        this.world.enemies = data.agents?.map((a, i) => Agent.fromJSON(a, i < data.agents.length/2 ? '#00d4ff' : '#ff5577')) || [];
        if (data.healthPacks) {
            this.world.healthPacks = data.healthPacks.map(p => HealthPack.fromJSON(p));
        }
        this.updateAgentList();
        this.updateStats();
        Logger.log('üìÇ Loaded', 'success');
    }

    exportWeights() {
        const data = { 
            version: '6.0.9-PROFESSIONAL', 
            timestamp: Date.now(), 
            config: arenaConfig,
            agents: this.world.enemies.map(a => a.toJSON()),
            world: {
                walls: this.world.walls.map(w => w instanceof Wall ? w.toJSON() : w),
                wallConfig: this.world._wallConfig,
                validatedSpawns: this.world._validatedSpawns
            }
        };
        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `arena-v6-pro-${Date.now()}.json`; a.click();
        URL.revokeObjectURL(url);
        Logger.log('üì§ Exported', 'success');
    }

    importWeights(e) {
        const file = e.target.files?.[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const data = JSON.parse(ev.target.result);
                if (data.version !== '6.0.9-PROFESSIONAL') throw new Error('Wrong version');
                this.world.enemies = data.agents.map((a, i) => Agent.fromJSON(a, i < data.agents.length/2 ? '#00d4ff' : '#ff5577'));
                if (data.world) {
                    this.world.walls = (data.world.walls || []).map(w => Wall.fromJSON(w));
                    this.world._wallConfig = data.world.wallConfig || null;
                    this.world._validatedSpawns = data.world.validatedSpawns || null;
                }
                this.updateAgentList();
                Logger.log('üì• Imported', 'success');
            } catch (err) { Logger.log(`‚ùå Error: ${err.message}`, 'error'); }
            e.target.value = '';
        };
        reader.readAsText(file);    }

    applyWeapons() {
        const blueWeapon = document.getElementById('blueWeaponSelect').value;
        const redWeapon = document.getElementById('redWeaponSelect').value;
        this.world.enemies.filter(a => a.team === 'blue').forEach(a => a.setWeapon(blueWeapon));
        this.world.enemies.filter(a => a.team === 'red').forEach(a => a.setWeapon(redWeapon));
        this.updateAgentList();
        Logger.log('‚úÖ Weapons applied', 'success');
    }

    randomWeapons() {
        const types = Object.keys(WEAPONS);
        const blue = types[Utils.randInt(0, types.length - 1)];
        const red = types[Utils.randInt(0, types.length - 1)];
        document.getElementById('blueWeaponSelect').value = blue;
        document.getElementById('redWeaponSelect').value = red;
        this.applyWeapons();
    }
}

// ============================================================================
// SECTION 12: INITIALIZATION
// ============================================================================

window.arenaGame = null;
if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initArena); else initArena();
function initArena() { try { window.arenaGame = new GameEngine(); console.log('‚úÖ Arena Professional v6.0.9 initialized'); } catch (e) { console.error('Init error:', e); alert('Error: ' + e.message); } }
window.addEventListener('beforeunload', () => { if (window.arenaGame) window.arenaGame = null; });
</script>
</body>
</html>
