<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Arena v2.1</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a15;
            color: #e0e0ff;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        #gameCanvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(18, 18, 37, 0.95);
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            border: 1px solid #2a2a45;
            min-width: 200px;
        }
        #ui h3 {
            color: #00f2ff;
            margin-bottom: 10px;
            font-size: 15px;
        }
        .stat {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }
        .stat-label { color: #b0b0d0; }
        .stat-value { color: #00ff9d; font-weight: bold; }
        .status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            font-size: 11px;
        }
        .status.ok { background: rgba(0, 255, 157, 0.2); color: #00ff9d; }
        .status.error { background: rgba(255, 85, 119, 0.2); color: #ff5577; }
        .status.loading { background: rgba(255, 170, 0, 0.2); color: #ffaa00; }
        button {
            margin-top: 10px;
            padding: 10px 20px;
            background: #00f2ff;
            color: #000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
        }
        button:hover { background: #00c4d4; }
        button:disabled { background: #444; color: #888; cursor: not-allowed; }
        #errorBox {
            position: absolute;
            top: 10px;
            right: 10px;
            max-width: 400px;
            background: rgba(255, 85, 119, 0.9);
            color: #fff;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <h3>üéÆ AI Arena v2.1</h3>
        <div class="stat">
            <span class="stat-label">Step:</span>
            <span class="stat-value" id="stepStat">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Agents:</span>
            <span class="stat-value" id="agentStat">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">FPS:</span>
            <span class="stat-value" id="fpsStat">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Brains:</span>
            <span class="stat-value" id="brainStat">0</span>
        </div>
        <div id="statusBox" class="status loading">‚è≥ Loading...</div>
        <button id="btnStart" disabled>‚ñ∂ Start</button>
        <button id="btnReset" disabled>üîÑ Reset</button>
    </div>

    <div id="errorBox"></div>

    <script type="module">
        // === –ì–õ–û–ë–ê–õ–¨–ù–´–ô –ü–ï–†–ï–•–û–í–ê–¢ –û–®–ò–ë–û–ö ===
        const errorBox = document.getElementById('errorBox');
        const statusBox = document.getElementById('statusBox');
        
        function showError(msg) {
            errorBox.style.display = 'block';
            errorBox.innerHTML = '<strong>‚ùå ERROR:</strong><br><br>' + msg.replace(/\n/g, '<br>');
            statusBox.className = 'status error';
            statusBox.textContent = '‚ùå Error';
        }

        function setStatus(msg, type) {
            statusBox.textContent = msg;
            statusBox.className = 'status ' + type;
        }

        try {
            // === 1. –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö CORTEX.JS ===
            setStatus('üì¶ Loading Cortex2Brain...', 'loading');
            const cortexModule = await import('./core/cortex.js');
            const { Cortex2Brain } = cortexModule;
            setStatus('‚úÖ Cortex2Brain loaded!', 'ok');
            document.getElementById('brainStat').textContent = '1';

            // === 2. –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö GAME.JS ===
            setStatus('üì¶ Loading GameEngine...', 'loading');
            const gameModule = await import('./game.js');
            const { GameEngine } = gameModule;
            setStatus('‚úÖ GameEngine loaded!', 'ok');

            // === 3. –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===
            setStatus('üéÆ Initializing engine...', 'loading');
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const engine = await new GameEngine({
                width: canvas.width,
                height: canvas.height,
                seed: 'arena_1'
            }).init();
            setStatus('‚úÖ Engine ready!', 'ok');

            // === 4. –°–û–ó–î–ê–ù–ò–ï –ê–ì–ï–ù–¢–û–í ===
            setStatus('ü§ñ Creating agents...', 'loading');
            engine.addAgent({
                id: 'blue',
                x: 200,
                y: 300,
                color: '#00d4ff',
                stats: { maxHealth: 100, damage: 3, speed: 22 }
            });

            engine.addAgent({
                id: 'red',
                x: 620,
                y: 300,
                color: '#ff5577',
                stats: { maxHealth: 100, damage: 3, speed: 22 }
            });
            document.getElementById('agentStat').textContent = engine.agents.size;
            setStatus('‚úÖ Agents created!', 'ok');

            // === 5. –°–û–ó–î–ê–ù–ò–ï –ú–û–ó–ì–û–í (CORTEX) ===
            setStatus('üß† Creating Cortex brains...', 'loading');
            const brains = new Map();
            for (const [id, agent] of engine.agents) {
                const brain = new Cortex2Brain({
                    seed: `brain_${id}`,
                    taskSpec: {
                        inputComplexity: 0.7,
                        temporalDepth: 0.4,
                        socialComplexity: 0.8
                    }
                });

                brain.configurePersonality({
                    traits: {
                        bravery: Math.random() * 0.6 + 0.2,
                        aggression: Math.random() * 0.6 + 0.2,
                        empathy: Math.random() * 0.5
                    }
                });

                brains.set(id, brain);
            }
            document.getElementById('brainStat').textContent = brains.size;
            setStatus('‚úÖ Brains connected to Cortex!', 'ok');

            // === 6. GAME LOOP ===
            let running = false;
            let lastTime = 0;
            let frameCount = 0;
            let fps = 0;

            function gameLoop(timestamp) {
                if (!running) return;

                const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
                lastTime = timestamp;

                engine.step(dt);

                // AI DECISIONS THROUGH CORTEX
                for (const [id, agent] of engine.agents) {
                    if (!agent.alive) continue;
                    const brain = brains.get(id);
                    if (!brain) continue;
                    
                    const sensors = getSensors(agent, engine);
                    const result = brain.forward(sensors, 0, null, {
                        others: getSocialContext(agent, engine)
                    });

                    agent.setThrottle(result.output[4]);
                    agent.setSteering(result.output[8]);
                    if (result.output[6] > 0.7) {
                        agent.requestAttack();
                    }
                }

                engine.render(ctx, { showGrid: true, showTrail: true });

                frameCount++;
                if (frameCount % 30 === 0) {
                    fps = Math.round(1 / dt);
                    document.getElementById('stepStat').textContent = engine.stepCount;
                    document.getElementById('fpsStat').textContent = fps;
                }

                requestAnimationFrame(gameLoop);
            }

            // === 7. CONTROLS ===
            document.getElementById('btnStart').disabled = false;
            document.getElementById('btnReset').disabled = false;
            setStatus('‚úÖ READY! Press Start', 'ok');

            document.getElementById('btnStart').onclick = () => {
                running = !running;
                if (running) {
                    lastTime = performance.now();
                    requestAnimationFrame(gameLoop);
                    document.getElementById('btnStart').textContent = '‚è∏ Pause';
                    setStatus('‚ñ∂ Running', 'ok');
                } else {
                    document.getElementById('btnStart').textContent = '‚ñ∂ Start';
                    setStatus('‚è∏ Paused', 'loading');
                }
            };

            document.getElementById('btnReset').onclick = () => {
                engine.reset();
                for (const brain of brains.values()) {
                    brain.resetEpisode();
                }
                setStatus('üîÑ Reset', 'ok');
            };

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                engine.config.width = canvas.width;
                engine.config.height = canvas.height;
            });

            // Utils
            window.Utils = {
                clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
                dist: (a, b) => Math.hypot((a?.x ?? 0) - (b?.x ?? 0), (a?.y ?? 0) - (b?.y ?? 0)),
                angleToTarget: (fromX, fromY, toX, toY, facing) => {
                    let angle = Math.atan2(toY - fromY, toX - fromX) - facing;
                    while (angle > Math.PI) angle -= Math.PI * 2;
                    while (angle < -Math.PI) angle += Math.PI * 2;
                    return angle;
                }
            };

            // Helpers
            function getSensors(agent, engine) {
                const sensors = new Array(64).fill(0);
                let nearestEnemy = null, nearestDist = Infinity;
                
                for (const [id, other] of engine.agents) {
                    if (other === agent || !other.alive) continue;
                    const dist = Utils.dist(agent, other);
                    if (dist < nearestDist) { nearestDist = dist; nearestEnemy = other; }
                }

                if (nearestEnemy) {
                    sensors[0] = (nearestEnemy.x - agent.x) / 400;
                    sensors[1] = (nearestEnemy.y - agent.y) / 300;
                    sensors[2] = nearestDist / 200;
                    sensors[3] = nearestEnemy.health / nearestEnemy.stats.maxHealth;
                }

                let nearestWall = null, nearestWallDist = Infinity;
                for (const wall of engine.world.walls) {
                    const dist = Utils.dist(agent, wall);
                    if (dist < nearestWallDist) { nearestWallDist = dist; nearestWall = wall; }
                }

                if (nearestWall) {
                    sensors[4] = (nearestWall.x - agent.x) / 400;
                    sensors[5] = (nearestWall.y - agent.y) / 300;
                    sensors[6] = nearestWallDist / 100;
                }

                sensors[7] = agent.x / 820;
                sensors[8] = agent.y / 600;
                sensors[9] = agent.health / agent.stats.maxHealth;
                sensors[10] = agent.vx / 25;
                sensors[11] = agent.vy / 25;

                return sensors;
            }

            function getSocialContext(agent, engine) {
                const others = [];
                for (const [id, other] of engine.agents) {
                    if (other === agent || !other.alive) continue;
                    others.push({
                        id: other.id,
                        distance: Utils.dist(agent, other),
                        healthRatio: other.health / other.stats.maxHealth,
                        aggression: 0.5
                    });
                }
                return { others, enemyId: others[0]?.id };
            }

        } catch (error) {
            showError(error.message + '\n\n' + error.stack);
        }
    </script>
</body>
</html>


